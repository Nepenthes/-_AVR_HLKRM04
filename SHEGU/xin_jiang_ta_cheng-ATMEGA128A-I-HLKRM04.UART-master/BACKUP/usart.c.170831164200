#include<iom128v.h>
#include<macros.h>
#include"string.h"

#define	 FOSC	   8000000
#define	 BAUD0	   19200
#define	 BAUD1	   19200

#define	 UART0_RX_BUFFER_SIZE	30
#define	 UART1_RX_BUFFER_SIZE	30

typedef	 unsigned char uchar;
typedef	 unsigned int  uint;

static volatile uchar UART0_RxHead,UART1_RxHead;

uchar UART0_RxBuff[UART0_RX_BUFFER_SIZE] = {0};
uchar UART1_RxBuff[UART1_RX_BUFFER_SIZE] = {0};

void delay(unsigned int ms){

 	 unsigned int i,j;
	 for( i=0;i<ms;i++)
	 for(j=0;j<1141;j++); //1141是在8MHz晶振下，通过软件仿真反复实验得到的数值
}

void usart0Init(void){

	 UCSR0B = 0x00;                   	//关闭UART00
	 UCSR0A =0x00;                     	//不使用倍速发送（异步）
	 UCSR0C =(1<<UCSZ01)|(1<<UCSZ00);   //数据位为8位
	 UBRR0L=(FOSC/16/(BAUD0+1))%256;    //异步正常情况下的计算公式
	 UBRR0H=(FOSC/16/(BAUD0+1))/256;
	 UCSR0B =(1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0);     //接收使能和发送使能
}

void usart1Init(void){

 	 UCSR1B = 0x00;   					//关闭USART1
 	 UCSR1A = 0x00;   					//不适使用倍速发送
 	 UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);	//数据位为八位
 	 UBRR1L=(FOSC/16/(BAUD1+1))%256;	//异步正常模式下，UBRR的计算公式
 	 UBRR1H=(FOSC/16/(BAUD1+1))/256;
 	 UCSR1B =(1<<RXEN1)|(1<<TXEN1)|(1<<RXCIE1); 	//接收使能，传送使能
}

void putchar0(unsigned char c){  

     while (!(UCSR0A&(1<<UDRE0)));		//表明发送器已经准备就绪
     UDR0=c;    						//将要发送的数据装入UDR0寄存器
}

void putchar1(unsigned char c){  

     while (!(UCSR1A&(1<<UDRE1)));
  	 UDR1=c;    
}

void puts0(char *s){
	 
	 while (*s){
	 
  	 	 putchar0(*s);
		 s++;
     } 
    putchar0(0x0a);//回车换行
 	putchar0(0x0d);
}
 
void puts1(char *s){

	 while (*s){
	 
  	 	 putchar1(*s);
		 s++;
     } 
     putchar1(0x0a);//回车换行
     putchar1(0x0d);
} 

#pragma interrupt_handler uart0_rx_isr:iv_USART0_RXC
void uart0_rx_isr(void){
	 
	uchar data,status;
	
	data   = UDR0;
	status = UCSR0A;
	if(!(status & 0x18)){
		
		UART0_RxBuff[UART0_RxHead++] = data;
		if(UART0_RxHead == (UART0_RX_BUFFER_SIZE-1) || (data == 0x0a)){
		
			UART0_RxBuff[UART0_RxHead] = '\0';
			UART0_RxHead = 0;
		}	
	}
}

#pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC
void uart1_rx_isr(void){
	 
	uchar data,status;
	
	data   = UDR1;
	status = UCSR1A;
	if(!(status & 0x18)){
		
		UART1_RxBuff[UART1_RxHead++] = data;
		if(UART1_RxHead == (UART1_RX_BUFFER_SIZE-1)){
		
			UART1_RxBuff[UART1_RxHead++] = '\0';
			UART1_RxHead = 0;
		}		
	}
}

void main(void)
{
  	  SEI();
	  
	  usart0Init();
	  usart1Init();
	  
	  while(1){
	  
	  		if(!(strcmp("abc",UART0_RxBuff)))puts0("bcd");
			delay(500);
			puts0(UART0_RxBuff);
	  }
}