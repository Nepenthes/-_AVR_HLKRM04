Interrupt Vectors
    00000 940C 02B5 JMP	__start|__text_start
    00024 940C 0344 JMP	_uart0_rx_isr
    0003C 940C 03CE JMP	_uart1_rx_isr

Program Code (text area)
__start|__text_start:
    002B5 EFCF      LDI	R28,0xFF
    002B6 E1D0      LDI	R29,0x10
    002B7 BFCD      OUT	0x3D,R28
    002B8 BFDE      OUT	0x3E,R29
    002B9 51CE      SUBI	R28,0x1E
    002BA 40D0      SBCI	R29,0
    002BB EA0A      LDI	R16,0xAA
    002BC 8308      ST	Y,R16
    002BD 2400      CLR	R0
    002BE ECE2      LDI	R30,0xC2
    002BF E0F5      LDI	R31,5
    002C0 E017      LDI	R17,7
    002C1 32EC      CPI	R30,0x2C
    002C2 07F1      CPC	R31,R17
    002C3 F011      BEQ	0x02C6
    002C4 9201      ST	Z+,R0
    002C5 CFFB      RJMP	0x02C1
    002C6 8300      ST	Z,R16
    002C7 EAE8      LDI	R30,0xA8
    002C8 E0F0      LDI	R31,0
    002C9 E0A0      LDI	R26,0
    002CA E0B1      LDI	R27,1
    002CB E015      LDI	R17,5
    002CC E000      LDI	R16,0
    002CD BF0B      OUT	0x3B,R16
    002CE 36EA      CPI	R30,0x6A
    002CF 07F1      CPC	R31,R17
    002D0 F021      BEQ	0x02D5
    002D1 95C8      LPM
    002D2 9631      ADIW	R30,1
    002D3 920D      ST	X+,R0
    002D4 CFF9      RJMP	0x02CE
    002D5 940E 0A8C CALL	_main
_exit:
    002D7 CFFF      RJMP	_exit
_delay:
  i                    --> R20
  j                    --> R22
  ms                   --> R16
    002D8 940E 0D23 CALL	push_xgsetF000
FILE: E:\My_GTAProject\塔城设故板\Software\usart.c
(0001) #include "usart.h"
(0002) 
(0003) 
(0004) const uchar *WIFICmd[] = {
(0005) 
(0006) 	0  
(0007) };
(0008) 
(0009) const uchar *ITFRCmd[] = {
(0010) 
(0011) 	0  
(0012) };
(0013) 
(0014) static volatile uchar UART0_RxHead,UART1_RxHead;		//串口数据缓存游标
(0015) 
(0016) uchar UART0_RxBuff[UART0_RX_BUFFER_SIZE];				//串口0缓存
(0017) uchar UART1_RxBuff[UART1_RX_BUFFER_SIZE];				//串口1缓存
(0018) 
(0019) uchar UART0_RxBuff_Queue[BUFFER0_QLENTH][UART0_RX_BUFFER_SIZE];	  //串口0缓存队列
(0020) uchar UART1_RxBuff_Queue[BUFFER1_QLENTH][UART1_RX_BUFFER_SIZE];	  //串口1缓存队列
(0021) 
(0022) void delay(unsigned int ms){
(0023) 
(0024)  	 unsigned int i,j;
(0025) 	 for( i=0;i<ms;i++)
    002DA 2744      CLR	R20
    002DB 2755      CLR	R21
    002DC C00B      RJMP	0x02E8
(0026) 	 for(j=0;j<1141;j++); //1141是在8MHz晶振下，通过软件仿真反复实验得到的数值
    002DD 2766      CLR	R22
    002DE 2777      CLR	R23
    002DF C002      RJMP	0x02E2
    002E0 5F6F      SUBI	R22,0xFF
    002E1 4F7F      SBCI	R23,0xFF
    002E2 3765      CPI	R22,0x75
    002E3 E0E4      LDI	R30,4
    002E4 077E      CPC	R23,R30
    002E5 F3D0      BCS	0x02E0
    002E6 5F4F      SUBI	R20,0xFF
    002E7 4F5F      SBCI	R21,0xFF
    002E8 1740      CP	R20,R16
    002E9 0751      CPC	R21,R17
    002EA F390      BCS	0x02DD
    002EB 940C 0D28 JMP	pop_xgsetF000
(0027) }
(0028) 
(0029) void usart0Init(void){
(0030) 
(0031) 	 UART0_RxHead = 0;
_usart0Init:
    002ED 2422      CLR	R2
    002EE 9220 072B STS	usart.c:UART0_RxHead,R2
(0032) 
(0033) 	 UCSR0B = 0x00;                   	//关闭UART00
    002F0 B82A      OUT	0x0A,R2
(0034) 	 UCSR0A =0x00;                     	//不使用倍速发送（异步）
    002F1 B82B      OUT	0x0B,R2
(0035) 	 UCSR0C =(1<<UCSZ01)|(1<<UCSZ00);   //数据位为8位
    002F2 E086      LDI	R24,6
    002F3 9380 0095 STS	0x95,R24
(0036) 	 UBRR0L=(FOSC/16/(BAUD0+1))%256;    //异步正常情况下的计算公式
    002F5 E384      LDI	R24,0x34
    002F6 B989      OUT	0x09,R24
(0037) 	 UBRR0H=(FOSC/16/(BAUD0+1))/256;
    002F7 9220 0090 STS	0x90,R2
(0038) 	 UCSR0B =(1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0);     //接收使能和发送使能以及中断
    002F9 E988      LDI	R24,0x98
    002FA B98A      OUT	0x0A,R24
    002FB 9508      RET
(0039) }
(0040) 
(0041) void usart1Init(void){
(0042) 
(0043) 	 UART1_RxHead = 0;
_usart1Init:
    002FC 2422      CLR	R2
    002FD 9220 072A STS	usart.c:UART1_RxHead,R2
(0044) 
(0045)  	 UCSR1B = 0x00;   					//关闭USART1
    002FF 9220 009A STS	0x9A,R2
(0046)  	 UCSR1A = 0x00;   					//不适使用倍速发送
    00301 9220 009B STS	0x9B,R2
(0047)  	 UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);	//数据位为八位
    00303 E086      LDI	R24,6
    00304 9380 009D STS	0x9D,R24
(0048)  	 UBRR1L=(FOSC/16/(BAUD1+1))%256;	//异步正常模式下，UBRR的计算公式
    00306 E384      LDI	R24,0x34
    00307 9380 0099 STS	0x99,R24
(0049)  	 UBRR1H=(FOSC/16/(BAUD1+1))/256;
    00309 9220 0098 STS	0x98,R2
(0050)  	 UCSR1B =(1<<RXEN1)|(1<<TXEN1)|(1<<RXCIE1); 	//接收使能，传送使能以及中断
    0030B E988      LDI	R24,0x98
    0030C 9380 009A STS	0x9A,R24
    0030E 9508      RET
(0051) }
(0052) 
(0053) void putchar0(unsigned char c){  
(0054) 
(0055)      while (!(UCSR0A&(1<<UDRE0)));		//表明发送器已经准备就绪
_putchar0:
  c                    --> R16
    0030F 9B5D      SBIS	0x0B,5
    00310 CFFE      RJMP	_putchar0
(0056)      UDR0=c;    						//将要发送的数据装入UDR0寄存器
    00311 B90C      OUT	0x0C,R16
    00312 9508      RET
(0057) }
(0058) 
(0059) void putchar1(unsigned char c){  
(0060) 
(0061)      while (!(UCSR1A&(1<<UDRE1)));
_putchar1:
  c                    --> R16
    00313 9020 009B LDS	R2,0x9B
    00315 FE25      SBRS	R2,5
    00316 CFFC      RJMP	_putchar1
(0062)   	 UDR1=c;    
    00317 9300 009C STS	0x9C,R16
    00319 9508      RET
_puts0:
  s                    --> R20
    0031A 934A      ST	-Y,R20
    0031B 935A      ST	-Y,R21
    0031C 01A8      MOVW	R20,R16
(0063) }
(0064) 
(0065) void puts0(char *s){
    0031D C005      RJMP	0x0323
(0066) 	 
(0067) 	 while (*s){
(0068) 	 
(0069)   	 	 putchar0(*s);
    0031E 01FA      MOVW	R30,R20
    0031F 8100      LD	R16,Z
    00320 DFEE      RCALL	_putchar0
(0070) 		 s++;
    00321 5F4F      SUBI	R20,0xFF
    00322 4F5F      SBCI	R21,0xFF
    00323 01FA      MOVW	R30,R20
    00324 8020      LD	R2,Z
    00325 2022      TST	R2
    00326 F7B9      BNE	0x031E
(0071)     } 
(0072) 	
(0073) 	putchar0(0xff);	  //包尾标识
    00327 EF0F      LDI	R16,0xFF
    00328 DFE6      RCALL	_putchar0
(0074)  	putchar0(0xff);
    00329 EF0F      LDI	R16,0xFF
    0032A DFE4      RCALL	_putchar0
(0075) 	putchar0(0xff);
    0032B EF0F      LDI	R16,0xFF
    0032C DFE2      RCALL	_putchar0
    0032D 9159      LD	R21,Y+
    0032E 9149      LD	R20,Y+
    0032F 9508      RET
_puts1:
  s                    --> R20
    00330 934A      ST	-Y,R20
    00331 935A      ST	-Y,R21
    00332 01A8      MOVW	R20,R16
(0076) }
(0077)  
(0078) void puts1(char *s){
    00333 C005      RJMP	0x0339
(0079) 
(0080) 	 while (*s){
(0081) 	 
(0082)   	 	 putchar1(*s);
    00334 01FA      MOVW	R30,R20
    00335 8100      LD	R16,Z
    00336 DFDC      RCALL	_putchar1
(0083) 		 s++;
    00337 5F4F      SUBI	R20,0xFF
    00338 4F5F      SBCI	R21,0xFF
    00339 01FA      MOVW	R30,R20
    0033A 8020      LD	R2,Z
    0033B 2022      TST	R2
    0033C F7B9      BNE	0x0334
(0084) 	}
(0085) 	
(0086) 	putchar1('\r');   //包尾标识
    0033D E00D      LDI	R16,0xD
    0033E DFD4      RCALL	_putchar1
(0087)  	putchar1('\n');
    0033F E00A      LDI	R16,0xA
    00340 DFD2      RCALL	_putchar1
    00341 9159      LD	R21,Y+
    00342 9149      LD	R20,Y+
    00343 9508      RET
_uart0_rx_isr:
  crp                  --> R10
  data                 --> R20
  status               --> R22
  loop                 --> R22
    00344 920A      ST	-Y,R0
    00345 921A      ST	-Y,R1
    00346 922A      ST	-Y,R2
    00347 923A      ST	-Y,R3
    00348 924A      ST	-Y,R4
    00349 925A      ST	-Y,R5
    0034A 926A      ST	-Y,R6
    0034B 927A      ST	-Y,R7
    0034C 928A      ST	-Y,R8
    0034D 929A      ST	-Y,R9
    0034E 930A      ST	-Y,R16
    0034F 931A      ST	-Y,R17
    00350 932A      ST	-Y,R18
    00351 933A      ST	-Y,R19
    00352 938A      ST	-Y,R24
    00353 939A      ST	-Y,R25
    00354 93AA      ST	-Y,R26
    00355 93BA      ST	-Y,R27
    00356 93EA      ST	-Y,R30
    00357 93FA      ST	-Y,R31
    00358 B60F      IN	R0,0x3F
    00359 920A      ST	-Y,R0
    0035A 940E 0D2D CALL	push_xgsetF00C
    0035C 9722      SBIW	R28,2
(0088) } 
(0089) 
(0090) #pragma interrupt_handler uart0_rx_isr:iv_USART0_RXC
(0091) void uart0_rx_isr(void){
(0092) 	 
(0093) 	uchar data,status,loop;
(0094) 	uchar crp = UART0_RxHead;
    0035D 90A0 072B LDS	R10,usart.c:UART0_RxHead
(0095) 	
(0096) 	data   = UDR0;
    0035F B14C      IN	R20,0x0C
(0097) 	status = UCSR0A;
    00360 B16B      IN	R22,0x0B
(0098) 
(0099) 	if(!(status & 0x18)){		
    00361 2F86      MOV	R24,R22
    00362 7188      ANDI	R24,0x18
    00363 F009      BEQ	0x0365
    00364 C04F      RJMP	0x03B4
(0100) 	
(0101) 		if((UART0_RxHead > (UART0_RX_BUFFER_SIZE-2)) || ((data == '\n') && (UART0_RxBuff[crp-1] == '\r'))){
    00365 E18C      LDI	R24,0x1C
    00366 9020 072B LDS	R2,usart.c:UART0_RxHead
    00368 1582      CP	R24,R2
    00369 F060      BCS	0x0376
    0036A 304A      CPI	R20,0xA
    0036B F009      BEQ	0x036D
    0036C C039      RJMP	0x03A6
    0036D E08B      LDI	R24,0xB
    0036E E097      LDI	R25,7
    0036F 2DEA      MOV	R30,R10
    00370 27FF      CLR	R31
    00371 0FE8      ADD	R30,R24
    00372 1FF9      ADC	R31,R25
    00373 8180      LD	R24,Z
    00374 308D      CPI	R24,0xD
    00375 F581      BNE	0x03A6
(0102) 			
(0103) 			UART0_RxHead = 0;
    00376 2422      CLR	R2
    00377 9220 072B STS	usart.c:UART0_RxHead,R2
(0104) 			
(0105) 			UART0_RxBuff[crp-1] = 0;
    00379 E08B      LDI	R24,0xB
    0037A E097      LDI	R25,7
    0037B 2DEA      MOV	R30,R10
    0037C 27FF      CLR	R31
    0037D 0FE8      ADD	R30,R24
    0037E 1FF9      ADC	R31,R25
    0037F 8220      ST	Z,R2
(0106) 				
(0107) 			for(loop = BUFFER0_QLENTH;loop > 1;loop --)			
    00380 E065      LDI	R22,5
    00381 C010      RJMP	0x0392
(0108) 				strcpy(UART0_RxBuff_Queue[loop - 1],UART0_RxBuff_Queue[loop - 2]);
    00382 E10E      LDI	R16,0x1E
    00383 2F16      MOV	R17,R22
    00384 0301      MULSU	R16,R17
    00385 E18C      LDI	R24,0x1C
    00386 E096      LDI	R25,6
    00387 0190      MOVW	R18,R0
    00388 0F28      ADD	R18,R24
    00389 1F39      ADC	R19,R25
    0038A E38A      LDI	R24,0x3A
    0038B E096      LDI	R25,6
    0038C 0180      MOVW	R16,R0
    0038D 0F08      ADD	R16,R24
    0038E 1F19      ADC	R17,R25
    0038F 940E 0CDE CALL	_strcpy
    00391 956A      DEC	R22
    00392 E081      LDI	R24,1
    00393 1786      CP	R24,R22
    00394 F368      BCS	0x0382
(0109) 				
(0110) 			strcpy(UART0_RxBuff_Queue[0],UART0_RxBuff);
    00395 E02C      LDI	R18,0xC
    00396 E037      LDI	R19,7
    00397 E508      LDI	R16,0x58
    00398 E016      LDI	R17,6
    00399 940E 0CDE CALL	_strcpy
(0111) 			memset(UART0_RxBuff,0,sizeof(uchar)*UART0_RX_BUFFER_SIZE);	//缓存清空
    0039B E18E      LDI	R24,0x1E
    0039C E090      LDI	R25,0
    0039D 8399      STD	Y+1,R25
    0039E 8388      ST	Y,R24
    0039F 2722      CLR	R18
    003A0 2733      CLR	R19
    003A1 E00C      LDI	R16,0xC
    003A2 E017      LDI	R17,7
    003A3 940E 0CC6 CALL	_memset
(0112) 	
(0113) 		}else UART0_RxBuff[UART0_RxHead++] = data;
    003A5 C00E      RJMP	0x03B4
    003A6 9020 072B LDS	R2,usart.c:UART0_RxHead
    003A8 2433      CLR	R3
    003A9 2D82      MOV	R24,R2
    003AA 5F8F      SUBI	R24,0xFF
    003AB 9380 072B STS	usart.c:UART0_RxHead,R24
    003AD E08C      LDI	R24,0xC
    003AE E097      LDI	R25,7
    003AF 2DE2      MOV	R30,R2
    003B0 27FF      CLR	R31
    003B1 0FE8      ADD	R30,R24
    003B2 1FF9      ADC	R31,R25
    003B3 8340      ST	Z,R20
(0114) 	}
    003B4 9622      ADIW	R28,2
    003B5 940E 0D34 CALL	pop_xgsetF00C
    003B7 9009      LD	R0,Y+
    003B8 BE0F      OUT	0x3F,R0
    003B9 91F9      LD	R31,Y+
    003BA 91E9      LD	R30,Y+
    003BB 91B9      LD	R27,Y+
    003BC 91A9      LD	R26,Y+
    003BD 9199      LD	R25,Y+
    003BE 9189      LD	R24,Y+
    003BF 9139      LD	R19,Y+
    003C0 9129      LD	R18,Y+
    003C1 9119      LD	R17,Y+
    003C2 9109      LD	R16,Y+
    003C3 9099      LD	R9,Y+
    003C4 9089      LD	R8,Y+
    003C5 9079      LD	R7,Y+
    003C6 9069      LD	R6,Y+
    003C7 9059      LD	R5,Y+
    003C8 9049      LD	R4,Y+
    003C9 9039      LD	R3,Y+
    003CA 9029      LD	R2,Y+
    003CB 9019      LD	R1,Y+
    003CC 9009      LD	R0,Y+
    003CD 9518      RETI
_uart1_rx_isr:
  crp                  --> R10
  data                 --> R20
  status               --> R22
  loop                 --> R22
    003CE 920A      ST	-Y,R0
    003CF 921A      ST	-Y,R1
    003D0 922A      ST	-Y,R2
    003D1 923A      ST	-Y,R3
    003D2 924A      ST	-Y,R4
    003D3 925A      ST	-Y,R5
    003D4 926A      ST	-Y,R6
    003D5 927A      ST	-Y,R7
    003D6 928A      ST	-Y,R8
    003D7 929A      ST	-Y,R9
    003D8 930A      ST	-Y,R16
    003D9 931A      ST	-Y,R17
    003DA 932A      ST	-Y,R18
    003DB 933A      ST	-Y,R19
    003DC 938A      ST	-Y,R24
    003DD 939A      ST	-Y,R25
    003DE 93AA      ST	-Y,R26
    003DF 93BA      ST	-Y,R27
    003E0 93EA      ST	-Y,R30
    003E1 93FA      ST	-Y,R31
    003E2 B60F      IN	R0,0x3F
    003E3 920A      ST	-Y,R0
    003E4 940E 0D2D CALL	push_xgsetF00C
    003E6 9722      SBIW	R28,2
(0115) }
(0116) 
(0117) #pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC
(0118) void uart1_rx_isr(void){
(0119) 	 
(0120) 	uchar data,status,loop;
(0121) 	uchar crp = UART1_RxHead;
    003E7 90A0 072A LDS	R10,usart.c:UART1_RxHead
(0122) 	
(0123) 	data   = UDR1;
    003E9 9140 009C LDS	R20,0x9C
(0124) 	status = UCSR1A;
    003EB 9160 009B LDS	R22,0x9B
(0125) 
(0126) 	if(!(status & 0x18)){		
    003ED 2F86      MOV	R24,R22
    003EE 7188      ANDI	R24,0x18
    003EF F009      BEQ	0x03F1
    003F0 C04F      RJMP	0x0440
(0127) 	
(0128) 		if((UART1_RxHead > (UART1_RX_BUFFER_SIZE-2)) || ((data == '\n') && (UART1_RxBuff[crp-1] == '\r'))){
    003F1 E18C      LDI	R24,0x1C
    003F2 9020 072A LDS	R2,usart.c:UART1_RxHead
    003F4 1582      CP	R24,R2
    003F5 F060      BCS	0x0402
    003F6 304A      CPI	R20,0xA
    003F7 F009      BEQ	0x03F9
    003F8 C039      RJMP	0x0432
    003F9 EE8D      LDI	R24,0xED
    003FA E096      LDI	R25,6
    003FB 2DEA      MOV	R30,R10
    003FC 27FF      CLR	R31
    003FD 0FE8      ADD	R30,R24
    003FE 1FF9      ADC	R31,R25
    003FF 8180      LD	R24,Z
    00400 308D      CPI	R24,0xD
    00401 F581      BNE	0x0432
(0129) 		
(0130) 			UART1_RxHead = 0;
    00402 2422      CLR	R2
    00403 9220 072A STS	usart.c:UART1_RxHead,R2
(0131) 			
(0132) 			UART1_RxBuff[crp-1] = 0;
    00405 EE8D      LDI	R24,0xED
    00406 E096      LDI	R25,6
    00407 2DEA      MOV	R30,R10
    00408 27FF      CLR	R31
    00409 0FE8      ADD	R30,R24
    0040A 1FF9      ADC	R31,R25
    0040B 8220      ST	Z,R2
(0133) 				
(0134) 			for(loop = BUFFER1_QLENTH;loop > 1;loop --)			
    0040C E065      LDI	R22,5
    0040D C010      RJMP	0x041E
(0135) 				strcpy(UART1_RxBuff_Queue[loop - 1],UART1_RxBuff_Queue[loop - 2]);
    0040E E10E      LDI	R16,0x1E
    0040F 2F16      MOV	R17,R22
    00410 0301      MULSU	R16,R17
    00411 E886      LDI	R24,0x86
    00412 E095      LDI	R25,5
    00413 0190      MOVW	R18,R0
    00414 0F28      ADD	R18,R24
    00415 1F39      ADC	R19,R25
    00416 EA84      LDI	R24,0xA4
    00417 E095      LDI	R25,5
    00418 0180      MOVW	R16,R0
    00419 0F08      ADD	R16,R24
    0041A 1F19      ADC	R17,R25
    0041B 940E 0CDE CALL	_strcpy
    0041D 956A      DEC	R22
    0041E E081      LDI	R24,1
    0041F 1786      CP	R24,R22
    00420 F368      BCS	0x040E
(0136) 				
(0137) 			strcpy(UART1_RxBuff_Queue[0],UART1_RxBuff);
    00421 EE2E      LDI	R18,0xEE
    00422 E036      LDI	R19,6
    00423 EC02      LDI	R16,0xC2
    00424 E015      LDI	R17,5
    00425 940E 0CDE CALL	_strcpy
(0138) 			memset(UART1_RxBuff,0,sizeof(uchar)*UART1_RX_BUFFER_SIZE);	//缓存清空
    00427 E18E      LDI	R24,0x1E
    00428 E090      LDI	R25,0
    00429 8399      STD	Y+1,R25
    0042A 8388      ST	Y,R24
    0042B 2722      CLR	R18
    0042C 2733      CLR	R19
    0042D EE0E      LDI	R16,0xEE
    0042E E016      LDI	R17,6
    0042F 940E 0CC6 CALL	_memset
(0139) 			
(0140) 		}else UART1_RxBuff[UART1_RxHead++] = data;		
    00431 C00E      RJMP	0x0440
    00432 9020 072A LDS	R2,usart.c:UART1_RxHead
    00434 2433      CLR	R3
    00435 2D82      MOV	R24,R2
    00436 5F8F      SUBI	R24,0xFF
    00437 9380 072A STS	usart.c:UART1_RxHead,R24
    00439 EE8E      LDI	R24,0xEE
    0043A E096      LDI	R25,6
    0043B 2DE2      MOV	R30,R2
    0043C 27FF      CLR	R31
    0043D 0FE8      ADD	R30,R24
    0043E 1FF9      ADC	R31,R25
    0043F 8340      ST	Z,R20
(0141) 	}
    00440 9622      ADIW	R28,2
    00441 940E 0D34 CALL	pop_xgsetF00C
    00443 9009      LD	R0,Y+
    00444 BE0F      OUT	0x3F,R0
    00445 91F9      LD	R31,Y+
    00446 91E9      LD	R30,Y+
    00447 91B9      LD	R27,Y+
    00448 91A9      LD	R26,Y+
    00449 9199      LD	R25,Y+
    0044A 9189      LD	R24,Y+
    0044B 9139      LD	R19,Y+
    0044C 9129      LD	R18,Y+
    0044D 9119      LD	R17,Y+
    0044E 9109      LD	R16,Y+
    0044F 9099      LD	R9,Y+
    00450 9089      LD	R8,Y+
    00451 9079      LD	R7,Y+
    00452 9069      LD	R6,Y+
    00453 9059      LD	R5,Y+
    00454 9049      LD	R4,Y+
    00455 9039      LD	R3,Y+
    00456 9029      LD	R2,Y+
    00457 9019      LD	R1,Y+
    00458 9009      LD	R0,Y+
    00459 9518      RETI
_ATTX_M1:
  time_point           --> R20
  rep                  --> R12
  wait_time            --> R14
  crp                  --> R10
  rec                  --> Y,+14
  command              --> Y,+12
  interface            --> R22
    0045A 933A      ST	-Y,R19
    0045B 932A      ST	-Y,R18
    0045C 940E 0D0E CALL	push_xgsetF0FC
    0045E 2F60      MOV	R22,R16
    0045F 9722      SBIW	R28,2
    00460 88A8      LDD	R10,Y+16
    00461 88EA      LDD	R14,Y+18
    00462 88FB      LDD	R15,Y+19
    00463 88CC      LDD	R12,Y+20
(0142) }
(0143) 
(0144) 
(0145) //输入：
(0146) //		interface：接口类型，'A'表示串口0，'B'表示串口1
(0147) //		command  ：命令
(0148) //		rec		 ：反馈
(0149) //		crp		 : 缓存游标
(0150) //		wait_time：单次等待时间
(0151) //		rep		 ：等待次数
(0152) //输出返回：
(0153) //		0：成功，1：失败
(0154) uchar ATTX_M1(uchar interface,uchar *command,uchar *rec,uchar crp,uint wait_time,uchar rep)
(0155) {
(0156) 	uchar time_point = 1;
    00464 E041      LDI	R20,1
(0157) 	
(0158) 	delay(100);
    00465 E604      LDI	R16,0x64
    00466 E010      LDI	R17,0
    00467 DE70      RCALL	_delay
(0159) 
(0160) 	if(interface == 'A'){
    00468 3461      CPI	R22,0x41
    00469 F009      BEQ	0x046B
    0046A C03F      RJMP	0x04AA
    0046B C01F      RJMP	0x048B
(0161) 		
(0162) 		while(strcmp(rec,UART0_RxBuff_Queue[crp])){
(0163) 		
(0164) 			memset(UART0_RxBuff_Queue[crp],0,sizeof(uchar)*UART0_RX_BUFFER_SIZE);
    0046C E18E      LDI	R24,0x1E
    0046D E090      LDI	R25,0
    0046E 8399      STD	Y+1,R25
    0046F 8388      ST	Y,R24
    00470 2722      CLR	R18
    00471 2733      CLR	R19
    00472 E10E      LDI	R16,0x1E
    00473 2D1A      MOV	R17,R10
    00474 0301      MULSU	R16,R17
    00475 0180      MOVW	R16,R0
    00476 E588      LDI	R24,0x58
    00477 E096      LDI	R25,6
    00478 0F08      ADD	R16,R24
    00479 1F19      ADC	R17,R25
    0047A 940E 0CC6 CALL	_memset
(0165) 			puts0(command);
    0047C 850C      LDD	R16,Y+12
    0047D 851D      LDD	R17,Y+13
    0047E DE9B      RCALL	_puts0
(0166) 			delay(wait_time);
    0047F 0187      MOVW	R16,R14
    00480 DE57      RCALL	_delay
(0167) 			time_point++;
    00481 9543      INC	R20
(0168) 			if(time_point > rep)return 1;
    00482 2C2C      MOV	R2,R12
    00483 2433      CLR	R3
    00484 2E44      MOV	R4,R20
    00485 2455      CLR	R5
    00486 1424      CP	R2,R4
    00487 0435      CPC	R3,R5
    00488 F414      BGE	0x048B
    00489 E001      LDI	R16,1
    0048A C065      RJMP	0x04F0
    0048B E10E      LDI	R16,0x1E
    0048C 2D1A      MOV	R17,R10
    0048D 0301      MULSU	R16,R17
    0048E 0190      MOVW	R18,R0
    0048F E588      LDI	R24,0x58
    00490 E096      LDI	R25,6
    00491 0F28      ADD	R18,R24
    00492 1F39      ADC	R19,R25
    00493 850E      LDD	R16,Y+14
    00494 851F      LDD	R17,Y+15
    00495 940E 0CD1 CALL	_strcmp
    00497 3000      CPI	R16,0
    00498 0701      CPC	R16,R17
    00499 F691      BNE	0x046C
(0169) 		}
(0170) 		memset(UART0_RxBuff_Queue[crp],0,sizeof(uchar)*UART0_RX_BUFFER_SIZE);	//缓存清空
    0049A E18E      LDI	R24,0x1E
    0049B E090      LDI	R25,0
    0049C 8399      STD	Y+1,R25
    0049D 8388      ST	Y,R24
    0049E 2722      CLR	R18
    0049F 2733      CLR	R19
    004A0 E10E      LDI	R16,0x1E
    004A1 2D1A      MOV	R17,R10
    004A2 0301      MULSU	R16,R17
    004A3 0180      MOVW	R16,R0
    004A4 E588      LDI	R24,0x58
    004A5 E096      LDI	R25,6
    004A6 0F08      ADD	R16,R24
    004A7 1F19      ADC	R17,R25
    004A8 940E 0CC6 CALL	_memset
(0171) 	}
(0172) 		
(0173) 	if(interface == 'B'){
    004AA 3462      CPI	R22,0x42
    004AB F009      BEQ	0x04AD
    004AC C03F      RJMP	0x04EC
    004AD C01F      RJMP	0x04CD
(0174) 		
(0175) 		while(strcmp(rec,UART1_RxBuff_Queue[crp])){
(0176) 		
(0177) 			memset(UART1_RxBuff_Queue[crp],0,sizeof(uchar)*UART1_RX_BUFFER_SIZE);
    004AE E18E      LDI	R24,0x1E
    004AF E090      LDI	R25,0
    004B0 8399      STD	Y+1,R25
    004B1 8388      ST	Y,R24
    004B2 2722      CLR	R18
    004B3 2733      CLR	R19
    004B4 E10E      LDI	R16,0x1E
    004B5 2D1A      MOV	R17,R10
    004B6 0301      MULSU	R16,R17
    004B7 0180      MOVW	R16,R0
    004B8 EC82      LDI	R24,0xC2
    004B9 E095      LDI	R25,5
    004BA 0F08      ADD	R16,R24
    004BB 1F19      ADC	R17,R25
    004BC 940E 0CC6 CALL	_memset
(0178) 			puts1(command);
    004BE 850C      LDD	R16,Y+12
    004BF 851D      LDD	R17,Y+13
    004C0 DE6F      RCALL	_puts1
(0179) 			delay(wait_time);
    004C1 0187      MOVW	R16,R14
    004C2 DE15      RCALL	_delay
(0180) 			time_point++;
    004C3 9543      INC	R20
(0181) 			if(time_point > rep)return 1;
    004C4 2C2C      MOV	R2,R12
    004C5 2433      CLR	R3
    004C6 2E44      MOV	R4,R20
    004C7 2455      CLR	R5
    004C8 1424      CP	R2,R4
    004C9 0435      CPC	R3,R5
    004CA F414      BGE	0x04CD
    004CB E001      LDI	R16,1
    004CC C023      RJMP	0x04F0
    004CD E10E      LDI	R16,0x1E
    004CE 2D1A      MOV	R17,R10
    004CF 0301      MULSU	R16,R17
    004D0 0190      MOVW	R18,R0
    004D1 EC82      LDI	R24,0xC2
    004D2 E095      LDI	R25,5
    004D3 0F28      ADD	R18,R24
    004D4 1F39      ADC	R19,R25
    004D5 850E      LDD	R16,Y+14
    004D6 851F      LDD	R17,Y+15
    004D7 940E 0CD1 CALL	_strcmp
    004D9 3000      CPI	R16,0
    004DA 0701      CPC	R16,R17
    004DB F691      BNE	0x04AE
(0182) 		}
(0183) 		memset(UART1_RxBuff_Queue[crp],0,sizeof(uchar)*UART1_RX_BUFFER_SIZE);	//缓存清空
    004DC E18E      LDI	R24,0x1E
    004DD E090      LDI	R25,0
    004DE 8399      STD	Y+1,R25
    004DF 8388      ST	Y,R24
    004E0 2722      CLR	R18
    004E1 2733      CLR	R19
    004E2 E10E      LDI	R16,0x1E
    004E3 2D1A      MOV	R17,R10
    004E4 0301      MULSU	R16,R17
    004E5 0180      MOVW	R16,R0
    004E6 EC82      LDI	R24,0xC2
    004E7 E095      LDI	R25,5
    004E8 0F08      ADD	R16,R24
    004E9 1F19      ADC	R17,R25
    004EA 940E 0CC6 CALL	_memset
(0184) 	}
(0185) 		
(0186) 	delay(100);
    004EC E604      LDI	R16,0x64
    004ED E010      LDI	R17,0
    004EE DDE9      RCALL	_delay
(0187) 	return 0;
    004EF 2700      CLR	R16
    004F0 9622      ADIW	R28,2
    004F1 940E 0D03 CALL	pop_xgsetF0FC
    004F3 9622      ADIW	R28,2
    004F4 9508      RET
_ATTX_M2:
  freq                 --> R22
  time_point           --> R20
  over_time            --> R12
  crp                  --> R10
  rec                  --> Y,+14
  command              --> Y,+12
  interface            --> R14
    004F5 933A      ST	-Y,R19
    004F6 932A      ST	-Y,R18
    004F7 940E 0D0E CALL	push_xgsetF0FC
    004F9 2EE0      MOV	R14,R16
    004FA 9722      SBIW	R28,2
    004FB 88A8      LDD	R10,Y+16
    004FC 88CA      LDD	R12,Y+18
    004FD 88DB      LDD	R13,Y+19
(0188) }
(0189) 
(0190) //输入：
(0191) //		interface：接口类型，'A'表示串口0，'B'表示串口1
(0192) //		command  ：命令
(0193) //		rec		 ：反馈
(0194) //		crp		 : 缓存游标
(0195) //		over_time：等待时间
(0196) //输出返回：
(0197) //		0：成功，1：失败
(0198) uchar ATTX_M2(uchar interface,uchar *command,uchar *rec,uchar crp,uint over_time)
(0199) {
(0200) 		
(0201) 	uint time_point = 1;
    004FE E041      LDI	R20,1
    004FF E050      LDI	R21,0
(0202) 	const uint freq = 200;			//轮询频次设定，200ms轮询一次
    00500 EC68      LDI	R22,0xC8
    00501 E070      LDI	R23,0
(0203) 	
(0204) 	delay(100);
    00502 E604      LDI	R16,0x64
    00503 E010      LDI	R17,0
    00504 DDD3      RCALL	_delay
(0205) 		
(0206) 	if(interface == 'A'){
    00505 2D8E      MOV	R24,R14
    00506 3481      CPI	R24,0x41
    00507 F581      BNE	0x0538
(0207) 	
(0208) 		puts0(command);
    00508 850C      LDD	R16,Y+12
    00509 851D      LDD	R17,Y+13
    0050A DE0F      RCALL	_puts0
    0050B C00D      RJMP	0x0519
(0209) 		while(strcmp(rec,UART0_RxBuff_Queue[crp])){
(0210) 			
(0211) 				delay(freq);
    0050C 018B      MOVW	R16,R22
    0050D DDCA      RCALL	_delay
(0212) 				if(time_point > over_time/freq)return 1;
    0050E 019B      MOVW	R18,R22
    0050F 0186      MOVW	R16,R12
    00510 940E 0CE9 CALL	div16u
    00512 1704      CP	R16,R20
    00513 0715      CPC	R17,R21
    00514 F410      BCC	0x0517
    00515 E001      LDI	R16,1
    00516 C058      RJMP	0x056F
(0213) 				time_point++;
    00517 5F4F      SUBI	R20,0xFF
    00518 4F5F      SBCI	R21,0xFF
    00519 E10E      LDI	R16,0x1E
    0051A 2D1A      MOV	R17,R10
    0051B 0301      MULSU	R16,R17
    0051C 0190      MOVW	R18,R0
    0051D E588      LDI	R24,0x58
    0051E E096      LDI	R25,6
    0051F 0F28      ADD	R18,R24
    00520 1F39      ADC	R19,R25
    00521 850E      LDD	R16,Y+14
    00522 851F      LDD	R17,Y+15
    00523 940E 0CD1 CALL	_strcmp
    00525 3000      CPI	R16,0
    00526 0701      CPC	R16,R17
    00527 F721      BNE	0x050C
(0214) 		}
(0215) 		memset(UART0_RxBuff_Queue[crp],0,sizeof(uchar)*UART0_RX_BUFFER_SIZE);	//缓存清空
    00528 E18E      LDI	R24,0x1E
    00529 E090      LDI	R25,0
    0052A 8399      STD	Y+1,R25
    0052B 8388      ST	Y,R24
    0052C 2722      CLR	R18
    0052D 2733      CLR	R19
    0052E E10E      LDI	R16,0x1E
    0052F 2D1A      MOV	R17,R10
    00530 0301      MULSU	R16,R17
    00531 0180      MOVW	R16,R0
    00532 E588      LDI	R24,0x58
    00533 E096      LDI	R25,6
    00534 0F08      ADD	R16,R24
    00535 1F19      ADC	R17,R25
    00536 940E 0CC6 CALL	_memset
(0216) 	}
(0217) 	
(0218) 	if(interface == 'B'){
    00538 2D8E      MOV	R24,R14
    00539 3482      CPI	R24,0x42
    0053A F581      BNE	0x056B
(0219) 	
(0220) 		puts1(command);
    0053B 850C      LDD	R16,Y+12
    0053C 851D      LDD	R17,Y+13
    0053D DDF2      RCALL	_puts1
    0053E C00D      RJMP	0x054C
(0221) 		while(strcmp(rec,UART1_RxBuff_Queue[crp])){
(0222) 			
(0223) 				delay(freq);
    0053F 018B      MOVW	R16,R22
    00540 DD97      RCALL	_delay
(0224) 				if(time_point > over_time/freq)return 1;
    00541 019B      MOVW	R18,R22
    00542 0186      MOVW	R16,R12
    00543 940E 0CE9 CALL	div16u
    00545 1704      CP	R16,R20
    00546 0715      CPC	R17,R21
    00547 F410      BCC	0x054A
    00548 E001      LDI	R16,1
    00549 C025      RJMP	0x056F
(0225) 				time_point++;
    0054A 5F4F      SUBI	R20,0xFF
    0054B 4F5F      SBCI	R21,0xFF
    0054C E10E      LDI	R16,0x1E
    0054D 2D1A      MOV	R17,R10
    0054E 0301      MULSU	R16,R17
    0054F 0190      MOVW	R18,R0
    00550 EC82      LDI	R24,0xC2
    00551 E095      LDI	R25,5
    00552 0F28      ADD	R18,R24
    00553 1F39      ADC	R19,R25
    00554 850E      LDD	R16,Y+14
    00555 851F      LDD	R17,Y+15
    00556 940E 0CD1 CALL	_strcmp
    00558 3000      CPI	R16,0
    00559 0701      CPC	R16,R17
    0055A F721      BNE	0x053F
(0226) 		}
(0227) 		memset(UART1_RxBuff_Queue[crp],0,sizeof(uchar)*UART1_RX_BUFFER_SIZE);	//缓存清空
    0055B E18E      LDI	R24,0x1E
    0055C E090      LDI	R25,0
    0055D 8399      STD	Y+1,R25
    0055E 8388      ST	Y,R24
    0055F 2722      CLR	R18
    00560 2733      CLR	R19
    00561 E10E      LDI	R16,0x1E
    00562 2D1A      MOV	R17,R10
    00563 0301      MULSU	R16,R17
    00564 0180      MOVW	R16,R0
    00565 EC82      LDI	R24,0xC2
    00566 E095      LDI	R25,5
    00567 0F08      ADD	R16,R24
    00568 1F19      ADC	R17,R25
    00569 940E 0CC6 CALL	_memset
(0228) 	}
(0229) 
(0230) 	delay(100);
    0056B E604      LDI	R16,0x64
    0056C E010      LDI	R17,0
    0056D DD6A      RCALL	_delay
(0231) 	return 0;
    0056E 2700      CLR	R16
    0056F 9622      ADIW	R28,2
    00570 940E 0D03 CALL	pop_xgsetF0FC
    00572 9622      ADIW	R28,2
    00573 9508      RET
(0232) }
(0233) 
(0234) void usart_init(void){
(0235) 
(0236)   	SEI();
_usart_init:
    00574 9478      BSET	7
(0237) 	  
(0238) 	usart0Init();
    00575 DD77      RCALL	_usart0Init
(0239) 	usart1Init();	 
    00576 CD85      RJMP	_usart1Init
_usart_test:
  temp                 --> R10
    00577 92AA      ST	-Y,R10
    00578 9726      SBIW	R28,6
(0240) }
(0241) 
(0242) void usart_test(void)
(0243) {
(0244)  	  uchar temp = UART1_RxHead;
    00579 90A0 072A LDS	R10,usart.c:UART1_RxHead
(0245) 
(0246)   	  SEI();
    0057B 9478      BSET	7
(0247) 	  
(0248) 	  usart0Init();
    0057C DD70      RCALL	_usart0Init
(0249) 	  usart1Init();
    0057D DD7E      RCALL	_usart1Init
(0250) 	  
(0251) 	  ATTX_M2('B',"abc","bcd",0,9000);  
    0057E E288      LDI	R24,0x28
    0057F E293      LDI	R25,0x23
    00580 839D      STD	Y+5,R25
    00581 838C      STD	Y+4,R24
    00582 2422      CLR	R2
    00583 822A      STD	Y+2,R2
    00584 E084      LDI	R24,4
    00585 E091      LDI	R25,1
    00586 8399      STD	Y+1,R25
    00587 8388      ST	Y,R24
    00588 E028      LDI	R18,0x8
    00589 E031      LDI	R19,1
    0058A E402      LDI	R16,0x42
    0058B DF69      RCALL	_ATTX_M2
    0058C C014      RJMP	0x05A1
(0252) 	  
(0253) 	  while(1){
(0254) 	  		   temp = UART0_RxHead;
    0058D 90A0 072B LDS	R10,usart.c:UART0_RxHead
(0255) 	  
(0256) 	  		putchar1(UART1_RxBuff[temp-2]);
    0058F EE8C      LDI	R24,0xEC
    00590 E096      LDI	R25,6
    00591 2DEA      MOV	R30,R10
    00592 27FF      CLR	R31
    00593 0FE8      ADD	R30,R24
    00594 1FF9      ADC	R31,R25
    00595 8100      LD	R16,Z
    00596 DD7C      RCALL	_putchar1
(0257) 			puts1(UART1_RxBuff_Queue[4]);
    00597 E30A      LDI	R16,0x3A
    00598 E016      LDI	R17,6
    00599 DD96      RCALL	_puts1
(0258) 			delay(500);
    0059A EF04      LDI	R16,0xF4
    0059B E011      LDI	R17,1
    0059C DD3B      RCALL	_delay
(0259) 			if(UART1_RxBuff[0]){
    0059D 9020 06EE LDS	R2,UART1_RxBuff
    0059F 2022      TST	R2
    005A0 F001      BEQ	0x05A1
    005A1 CFEB      RJMP	0x058D
    005A2 9626      ADIW	R28,6
    005A3 90A9      LD	R10,Y+
    005A4 9508      RET
FILE: E:\My_GTAProject\塔城设故板\Software\user_main.c
(0001) #include "usart.h"
(0002) #include "IO_control.h"
(0003) 
(0004) const uchar *ITFR_CMD[4+2+3+3+2] = {
(0005) 
(0006) 	"res_fengshan.fs_res1.txt=\"0\"",			//1
(0007) 	"res_fengshan.fs_res2.txt=\"0\"",
(0008) 	"res_fengshan.fs_res3.txt=\"0\"",
(0009) 	"res_fengshan.fs_res4.txt=\"0\"",
(0010) 	
(0011) 	"res_dianfanbao.dfb_res1.txt=\"0\"",		//5
(0012) 	"res_dianfanbao.dfb_res2.txt=\"0\"",
(0013) 	"res_dianfanbao.dfb_res3.txt=\"0\"",
(0014) 	
(0015) 	"res_weibolu.wbl_res1.txt=\"0\"",			//8
(0016) 	"res_weibolu.wbl_res2.txt=\"0\"",
(0017) 	
(0018) 	"res_xiaodugui.xdg_res1.txt=\"0\"",			//10
(0019) 	"res_xiaodugui.xdg_res2.txt=\"0\"",
(0020) 	
(0021) 	"res_xiyiji.xyj_res1.txt=\"0\"",			//12
(0022) 	"res_xiyiji.xyj_res2.txt=\"0\"",
(0023) 	"res_xiyiji.xyj_res3.txt=\"0\"",	
(0024) };
(0025) 
(0026) const uchar *WIFI_CMD[17] = {
(0027) 
(0028) 	"at+netmode=2",
(0029) 	"at+dhcpd=0",
(0030) 	"at+wifi_conf="WIFI_INFORMATION,
(0031) 	"at+dhcpc=0",
(0032) //	"at+net_ip="device_IP",255.255.255.0,10.2.8.254",
(0033) 	"at+net_ip="device_IP",255.255.255.0,192.168.0.1",
(0034) //	"at+net_dns=202.96.128.86,202.96.134.33",
(0035) 	"at+net_dns=192.168.0.1,0.0.0.0",
(0036) 	"at+remotepro=tcp",
(0037) 	"at+mode=client",
(0038) //	"at+remoteip=10.2.8.139",
(0039) 	"at+remoteip=192.168.0.103",
(0040) 	"at+remoteport=8088",
(0041) 	"at+CLport=1234",
(0042) 	"at+timeout=0",
(0043) 	"at+uart=9600,8,n,1",
(0044) 	"at+uartpacklen=64",
(0045) 	"at+uartpacktimeout=10",
(0046) 	"at+net_commit=1",
(0047) 	"at+reconn=1"
(0048) };
(0049) 
(0050) const char cntConfirm[8] = {0x5a,device_ID,0x03,0x40,0x40,0x40,0x40};
(0051) 
(0052) extern uchar WIFI_BUF_QUE[BUFFER0_QLENTH][UART0_RX_BUFFER_SIZE];	
(0053) extern uchar ITFR_BUF_QUE[BUFFER1_QLENTH][UART1_RX_BUFFER_SIZE];	
(0054) 
(0055) extern infoMal infoMal_teacher;
(0056) extern infoMal infoMal_student;
(0057) 
(0058) extern uchar resIOJudge[9];	   		//老师设故与学生解故比较结果存放
(0059) 
(0060) infoUser userMe 	 = {"00000000","00000000"};
(0061) infoUser userMe_temp = {"00000000","00000000"};
(0062) 
(0063) uchar UI_pt = 0x00;	   		//UI界面游标，指向当前所显示界面
(0064) 
(0065) void delay_3us(void);
(0066) void wifiConnecting(void);
(0067) 
(0068) void delay_3us(void)  //3us延时函数,,可重复调用不影响精度 
(0069) {
(0070)    asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
_delay_3us:
    005A5 0000      NOP
    005A6 0000      NOP
    005A7 0000      NOP
    005A8 0000      NOP
    005A9 0000      NOP
    005AA 0000      NOP
(0071)    asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
    005AB 0000      NOP
    005AC 0000      NOP
    005AD 0000      NOP
    005AE 0000      NOP
    005AF 0000      NOP
    005B0 0000      NOP
(0072)    asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
    005B1 0000      NOP
    005B2 0000      NOP
    005B3 0000      NOP
    005B4 0000      NOP
    005B5 0000      NOP
    005B6 0000      NOP
    005B7 9508      RET
(0073) }
(0074) 
(0075) void delay_10us(void)  //10us延时函数,可重复调用不影响精度
(0076) {
(0077)  	delay_3us();
_delay_10us:
    005B8 DFEC      RCALL	_delay_3us
(0078)  	delay_3us();
    005B9 DFEB      RCALL	_delay_3us
(0079)  	delay_3us();
    005BA CFEA      RJMP	_delay_3us
(0080) }
(0081) 
(0082) void delay_50us(void)  //48us延时函数,可重复调用不影响精度
(0083) {      
(0084)   	delay_10us();    
_delay_50us:
    005BB DFFC      RCALL	_delay_10us
(0085)   	delay_10us();    
    005BC DFFB      RCALL	_delay_10us
(0086)   	delay_10us();   
    005BD DFFA      RCALL	_delay_10us
(0087)   	delay_10us();    
    005BE DFF9      RCALL	_delay_10us
(0088)   	delay_10us();
    005BF CFF8      RJMP	_delay_10us
(0089) }
(0090)  
(0091) void delay_100us(void)//exactly 98us延时函数,可重复调用不影响精度
(0092) {
(0093)   delay_50us();
_delay_100us:
    005C0 DFFA      RCALL	_delay_50us
(0094)   delay_50us();
    005C1 DFF9      RCALL	_delay_50us
(0095)   delay_3us();
    005C2 CFE2      RJMP	_delay_3us
(0096) }
(0097)  
(0098) void delay_1ms(void)            
(0099) {
(0100)   delay_100us(); delay_100us(); delay_100us(); delay_100us(); delay_100us();
_delay_1ms:
    005C3 DFFC      RCALL	_delay_100us
    005C4 DFFB      RCALL	_delay_100us
    005C5 DFFA      RCALL	_delay_100us
    005C6 DFF9      RCALL	_delay_100us
    005C7 DFF8      RCALL	_delay_100us
(0101)   delay_100us(); delay_100us(); delay_100us(); delay_100us(); delay_100us();
    005C8 DFF7      RCALL	_delay_100us
    005C9 DFF6      RCALL	_delay_100us
    005CA DFF5      RCALL	_delay_100us
    005CB DFF4      RCALL	_delay_100us
    005CC CFF3      RJMP	_delay_100us
_delay_ms:
  ms                   --> R20
    005CD 934A      ST	-Y,R20
    005CE 935A      ST	-Y,R21
    005CF 01A8      MOVW	R20,R16
(0102) }
(0103)   
(0104)  void delay_ms(uint ms )
(0105) {
    005D0 C001      RJMP	0x05D2
(0106)     while(ms--)  
(0107) 		delay_1ms();//8MHZ主频时，25分钟误差小于1秒
    005D1 DFF1      RCALL	_delay_1ms
    005D2 011A      MOVW	R2,R20
    005D3 5041      SUBI	R20,1
    005D4 4050      SBCI	R21,0
    005D5 2022      TST	R2
    005D6 F7D1      BNE	0x05D1
    005D7 2033      TST	R3
    005D8 F7C1      BNE	0x05D1
    005D9 9159      LD	R21,Y+
    005DA 9149      LD	R20,Y+
    005DB 9508      RET
(0108) }
(0109) 
(0110) void EEPROM_write(uchar addr,uchar data){
(0111) 
(0112) 	while(EECR & BIT(EEWE));
_EEPROM_write:
  data                 --> R18
  addr                 --> R16
    005DC 99E1      SBIC	0x1C,1
    005DD CFFE      RJMP	_EEPROM_write
(0113) 	EEAR=addr;
    005DE 2E20      MOV	R2,R16
    005DF 2433      CLR	R3
    005E0 BA3F      OUT	0x1F,R3
    005E1 BA2E      OUT	0x1E,R2
(0114) 	EEDR=data;
    005E2 BB2D      OUT	0x1D,R18
(0115) 	EECR|=BIT(EEMWE);
    005E3 9AE2      SBI	0x1C,2
(0116) 	EECR|=BIT(EEWE);
    005E4 9AE1      SBI	0x1C,1
    005E5 9508      RET
(0117) }
(0118) 
(0119) uchar EEPROM_read(uchar addr){
(0120) 
(0121)  	while(EECR & BIT(EEWE));
_EEPROM_read:
  addr                 --> R16
    005E6 99E1      SBIC	0x1C,1
    005E7 CFFE      RJMP	_EEPROM_read
(0122) 	EEAR=addr;
    005E8 2E20      MOV	R2,R16
    005E9 2433      CLR	R3
    005EA BA3F      OUT	0x1F,R3
    005EB BA2E      OUT	0x1E,R2
(0123) 	EECR|=BIT(EERE);
    005EC 9AE0      SBI	0x1C,0
(0124) 	return EEDR;
    005ED B30D      IN	R16,0x1D
    005EE 9508      RET
_userID_read:
  loop                 --> R20
  Dats                 --> R10
    005EF 940E 0D19 CALL	push_xgset300C
    005F1 0158      MOVW	R10,R16
(0125) }
(0126) 
(0127) void userID_read(uchar Dats[8]){
(0128) 	 
(0129) 	uchar loop;
(0130) 	
(0131) 	for(loop = 0;loop < 8;loop ++)
    005F2 2744      CLR	R20
    005F3 C009      RJMP	0x05FD
(0132) 		Dats[loop] = EEPROM_read(loop+0x10);
    005F4 2F04      MOV	R16,R20
    005F5 5F00      SUBI	R16,0xF0
    005F6 DFEF      RCALL	_EEPROM_read
    005F7 2FE4      MOV	R30,R20
    005F8 27FF      CLR	R31
    005F9 0DEA      ADD	R30,R10
    005FA 1DFB      ADC	R31,R11
    005FB 8300      ST	Z,R16
    005FC 9543      INC	R20
    005FD 3048      CPI	R20,0x8
    005FE F3A8      BCS	0x05F4
    005FF 940C 0D1E JMP	pop_xgset300C
_userID_write:
  loop                 --> R20
  Dats                 --> R10
    00601 940E 0D19 CALL	push_xgset300C
    00603 0158      MOVW	R10,R16
(0133) }
(0134) 
(0135) void userID_write(uchar Dats[8]){		   //eeprom读用户名
(0136) 	 
(0137) 	uchar loop;
(0138) 	
(0139) 	for(loop = 0;loop < 8;loop ++)
    00604 2744      CLR	R20
    00605 C009      RJMP	0x060F
(0140) 		EEPROM_write(loop+0x10,Dats[loop]);
    00606 2FE4      MOV	R30,R20
    00607 27FF      CLR	R31
    00608 0DEA      ADD	R30,R10
    00609 1DFB      ADC	R31,R11
    0060A 8120      LD	R18,Z
    0060B 2F04      MOV	R16,R20
    0060C 5F00      SUBI	R16,0xF0
    0060D DFCE      RCALL	_EEPROM_write
    0060E 9543      INC	R20
    0060F 3048      CPI	R20,0x8
    00610 F3A8      BCS	0x0606
    00611 940C 0D1E JMP	pop_xgset300C
_password_read:
  loop                 --> R20
  Dats                 --> R10
    00613 940E 0D19 CALL	push_xgset300C
    00615 0158      MOVW	R10,R16
(0141) }
(0142) 
(0143) 
(0144) void password_read(uchar Dats[8]){		   //eeprom读密码
(0145) 	 
(0146) 	uchar loop;
(0147) 	
(0148) 	for(loop = 0;loop < 8;loop ++)
    00616 2744      CLR	R20
    00617 C009      RJMP	0x0621
(0149) 		Dats[loop] = EEPROM_read(loop+0x20);
    00618 2F04      MOV	R16,R20
    00619 5E00      SUBI	R16,0xE0
    0061A DFCB      RCALL	_EEPROM_read
    0061B 2FE4      MOV	R30,R20
    0061C 27FF      CLR	R31
    0061D 0DEA      ADD	R30,R10
    0061E 1DFB      ADC	R31,R11
    0061F 8300      ST	Z,R16
    00620 9543      INC	R20
    00621 3048      CPI	R20,0x8
    00622 F3A8      BCS	0x0618
    00623 940C 0D1E JMP	pop_xgset300C
_password_write:
  loop                 --> R20
  Dats                 --> R10
    00625 940E 0D19 CALL	push_xgset300C
    00627 0158      MOVW	R10,R16
(0150) }
(0151) 
(0152) void password_write(uchar Dats[8]){
(0153) 	 
(0154) 	uchar loop;
(0155) 	
(0156) 	for(loop = 0;loop < 8;loop ++)
    00628 2744      CLR	R20
    00629 C009      RJMP	0x0633
(0157) 		EEPROM_write(loop+0x20,Dats[loop]);
    0062A 2FE4      MOV	R30,R20
    0062B 27FF      CLR	R31
    0062C 0DEA      ADD	R30,R10
    0062D 1DFB      ADC	R31,R11
    0062E 8120      LD	R18,Z
    0062F 2F04      MOV	R16,R20
    00630 5E00      SUBI	R16,0xE0
    00631 DFAA      RCALL	_EEPROM_write
    00632 9543      INC	R20
    00633 3048      CPI	R20,0x8
    00634 F3A8      BCS	0x062A
    00635 940C 0D1E JMP	pop_xgset300C
_reaptRes:
  loop                 --> R20
    00637 934A      ST	-Y,R20
(0158) }
(0159) 
(0160) void reaptRes(void){					   //提交结果
(0161) 
(0162) 	 uchar loop;
(0163) 	 
(0164) 	 for(loop = 0;loop < 4;loop ++)
    00638 2744      CLR	R20
    00639 C010      RJMP	0x064A
(0165) 	 	if(resIOJudge[loop] == 0)resIOJudge[loop] = 0x40;
    0063A EB89      LDI	R24,0xB9
    0063B E095      LDI	R25,5
    0063C 2FE4      MOV	R30,R20
    0063D 27FF      CLR	R31
    0063E 0FE8      ADD	R30,R24
    0063F 1FF9      ADC	R31,R25
    00640 8020      LD	R2,Z
    00641 2022      TST	R2
    00642 F431      BNE	0x0649
    00643 2FE4      MOV	R30,R20
    00644 27FF      CLR	R31
    00645 0FE8      ADD	R30,R24
    00646 1FF9      ADC	R31,R25
    00647 E480      LDI	R24,0x40
    00648 8380      ST	Z,R24
    00649 9543      INC	R20
    0064A 3044      CPI	R20,4
    0064B F370      BCS	0x063A
(0166) 
(0167) 	 WIFI_PUTC(0x5a);
    0064C E50A      LDI	R16,0x5A
    0064D 940E 0313 CALL	_putchar1
(0168) 	 WIFI_PUTC(device_ID);
    0064F E005      LDI	R16,5
    00650 940E 0313 CALL	_putchar1
(0169) 	 WIFI_PUTC(0x20);
    00652 E200      LDI	R16,0x20
    00653 940E 0313 CALL	_putchar1
(0170) 	 WIFI_PUTS(resIOJudge);
    00655 EB09      LDI	R16,0xB9
    00656 E015      LDI	R17,5
    00657 940E 0330 CALL	_puts1
    00659 9149      LD	R20,Y+
    0065A 9508      RET
(0171) }
(0172) 
(0173) void bspInit(void)		   				   //初始化
(0174) {	
(0175)  	usart_init();						   //串口初始化
_bspInit:
    0065B 940E 0574 CALL	_usart_init
(0176) 	
(0177) 	ITFR_PUTS("page connecting");		   //首页
    0065D EA07      LDI	R16,0xA7
    0065E E012      LDI	R17,2
    0065F 940E 031A CALL	_puts0
(0178) 	
(0179) 	IOReinstate();						   //端口复位及信息清空
    00661 940E 0B26 CALL	_IOReinstate
(0180) 	
(0181) 	wifiConnecting();
    00663 D036      RCALL	_wifiConnecting
(0182) 	
(0183) 	userID_read(userMe.userID);			   //读用户
    00664 E502      LDI	R16,0x52
    00665 E011      LDI	R17,1
    00666 DF88      RCALL	_userID_read
(0184) 	password_read(userMe.password);		   //读密码
    00667 E50B      LDI	R16,0x5B
    00668 E011      LDI	R17,1
    00669 CFA9      RJMP	_password_read
_getConnect:
  loopa                --> R20
    0066A 934A      ST	-Y,R20
(0185) }
(0186) 
(0187) void getConnect(void){
(0188) 
(0189) 	uchar loopa;
(0190) 	
(0191) 	for(loopa = 0;loopa < 30;loopa ++){
    0066B 2744      CLR	R20
    0066C C007      RJMP	0x0674
(0192) 				  
(0193) 		WIFI_PUTC('+');
    0066D E20B      LDI	R16,0x2B
    0066E 940E 0313 CALL	_putchar1
(0194) 		delay_ms(100);
    00670 E604      LDI	R16,0x64
    00671 E010      LDI	R17,0
    00672 DF5A      RCALL	_delay_ms
    00673 9543      INC	R20
    00674 314E      CPI	R20,0x1E
    00675 F3B8      BCS	0x066D
(0195) 	}
(0196) 		
(0197) 	for(loopa = 0;loopa < 17;loopa ++)
    00676 2744      CLR	R20
    00677 C00D      RJMP	0x0685
(0198) 		WIFI_PUTS((uchar*)WIFI_CMD[loopa]);
    00678 E288      LDI	R24,0x28
    00679 E091      LDI	R25,1
    0067A 2FE4      MOV	R30,R20
    0067B 27FF      CLR	R31
    0067C 0FEE      LSL	R30
    0067D 1FFF      ROL	R31
    0067E 0FE8      ADD	R30,R24
    0067F 1FF9      ADC	R31,R25
    00680 8100      LD	R16,Z
    00681 8111      LDD	R17,Z+1
    00682 940E 0330 CALL	_puts1
    00684 9543      INC	R20
    00685 3141      CPI	R20,0x11
    00686 F388      BCS	0x0678
(0199) 		
(0200) 	delay_ms(500);
    00687 EF04      LDI	R16,0xF4
    00688 E011      LDI	R17,1
    00689 DF43      RCALL	_delay_ms
(0201) 	WIFI_PUTS("at+reconn=1");
    0068A EB07      LDI	R16,0xB7
    0068B E012      LDI	R17,2
    0068C 940E 0330 CALL	_puts1
(0202) 	delay_ms(500);
    0068E EF04      LDI	R16,0xF4
    0068F E011      LDI	R17,1
    00690 DF3C      RCALL	_delay_ms
(0203) 	WIFI_PUTS("at+reconn=1");
    00691 EB07      LDI	R16,0xB7
    00692 E012      LDI	R17,2
    00693 940E 0330 CALL	_puts1
(0204) 	delay_ms(500);
    00695 EF04      LDI	R16,0xF4
    00696 E011      LDI	R17,1
    00697 DF35      RCALL	_delay_ms
    00698 9149      LD	R20,Y+
    00699 9508      RET
_wifiConnecting:
    0069A 9727      SBIW	R28,7
(0205) }
(0206) 
(0207) void wifiConnecting(void){	 			   //初始化连接
(0208) 	
(0209) 	ITFR_PUTS("page connecting");
    0069B EA07      LDI	R16,0xA7
    0069C E012      LDI	R17,2
    0069D 940E 031A CALL	_puts0
(0210) 	UI_pt = 0x00;
    0069F 2422      CLR	R2
    006A0 9220 0176 STS	UI_pt,R2
    006A2 C020      RJMP	0x06C3
(0211) 	
(0212) 	while(1)
(0213) 	if(!ATTX_M1(WIFI,(char*)cntConfirm,(char*)cntConfirm,0,1000,6))
    006A3 E086      LDI	R24,6
    006A4 838E      STD	Y+6,R24
    006A5 EE88      LDI	R24,0xE8
    006A6 E093      LDI	R25,3
    006A7 839D      STD	Y+5,R25
    006A8 838C      STD	Y+4,R24
    006A9 2422      CLR	R2
    006AA 822A      STD	Y+2,R2
    006AB E48A      LDI	R24,0x4A
    006AC E091      LDI	R25,1
    006AD 8399      STD	Y+1,R25
    006AE 8388      ST	Y,R24
    006AF E42A      LDI	R18,0x4A
    006B0 E031      LDI	R19,1
    006B1 E402      LDI	R16,0x42
    006B2 940E 045A CALL	_ATTX_M1
    006B4 2300      TST	R16
    006B5 F441      BNE	0x06BE
(0214) 	{
(0215) 	
(0216) 		ITFR_PUTS("page main");
    006B6 E90D      LDI	R16,0x9D
    006B7 E012      LDI	R17,2
    006B8 940E 031A CALL	_puts0
(0217) 		UI_pt = 0x01;
    006BA E081      LDI	R24,1
    006BB 9380 0176 STS	UI_pt,R24
(0218) 		return;
    006BD C006      RJMP	0x06C4
(0219) 	}
(0220) 	else 
(0221) 	{
(0222) 	 	 
(0223) 	 	getConnect();
    006BE DFAB      RCALL	_getConnect
(0224) 		ITFR_PUTS("page connecting");
    006BF EA07      LDI	R16,0xA7
    006C0 E012      LDI	R17,2
    006C1 940E 031A CALL	_puts0
    006C3 CFDF      RJMP	0x06A3
    006C4 9627      ADIW	R28,7
    006C5 9508      RET
_wifiReconnect:
    006C6 934A      ST	-Y,R20
    006C7 935A      ST	-Y,R21
    006C8 9727      SBIW	R28,7
(0225) 	}
(0226) }
(0227) 
(0228) void wifiReconnect(void){			 		//中途断开重连
(0229) 	
(0230) 	ITFR_PUTS("page reconnect");
    006C9 E80E      LDI	R16,0x8E
    006CA E012      LDI	R17,2
    006CB 940E 031A CALL	_puts0
    006CD C02E      RJMP	0x06FC
(0231) 	
(0232) 	while(1)
(0233) 	if(!ATTX_M1(WIFI,(char*)cntConfirm,(char*)cntConfirm,0,1000,6))
    006CE E086      LDI	R24,6
    006CF 838E      STD	Y+6,R24
    006D0 EE88      LDI	R24,0xE8
    006D1 E093      LDI	R25,3
    006D2 839D      STD	Y+5,R25
    006D3 838C      STD	Y+4,R24
    006D4 2422      CLR	R2
    006D5 822A      STD	Y+2,R2
    006D6 E48A      LDI	R24,0x4A
    006D7 E091      LDI	R25,1
    006D8 8399      STD	Y+1,R25
    006D9 8388      ST	Y,R24
    006DA E42A      LDI	R18,0x4A
    006DB E031      LDI	R19,1
    006DC E402      LDI	R16,0x42
    006DD 940E 045A CALL	_ATTX_M1
    006DF 2300      TST	R16
    006E0 F4B1      BNE	0x06F7
(0234) 	{
(0235) 	
(0236) 		switch(UI_pt){
    006E1 9140 0176 LDS	R20,UI_pt
    006E3 2755      CLR	R21
    006E4 3041      CPI	R20,1
    006E5 E0E0      LDI	R30,0
    006E6 075E      CPC	R21,R30
    006E7 F029      BEQ	0x06ED
    006E8 3042      CPI	R20,2
    006E9 E0E0      LDI	R30,0
    006EA 075E      CPC	R21,R30
    006EB F031      BEQ	0x06F2
    006EC C010      RJMP	0x06FD
(0237) 		
(0238) 			case 0x01:	ITFR_PUTS("page main");					   break;
    006ED E90D      LDI	R16,0x9D
    006EE E012      LDI	R17,2
    006EF 940E 031A CALL	_puts0
    006F1 C00B      RJMP	0x06FD
(0239) 			case 0x02:	ITFR_PUTS("page device_select");		   break;
    006F2 E70B      LDI	R16,0x7B
    006F3 E012      LDI	R17,2
    006F4 940E 031A CALL	_puts0
(0240) 			default:	break;
(0241) 		}
(0242) 		return;
    006F6 C006      RJMP	0x06FD
(0243) 	}
(0244) 	else 
(0245) 	{
(0246) 	 	 
(0247) 	 	getConnect();
    006F7 DF72      RCALL	_getConnect
(0248) 		ITFR_PUTS("page reconnect");
    006F8 E80E      LDI	R16,0x8E
    006F9 E012      LDI	R17,2
    006FA 940E 031A CALL	_puts0
    006FC CFD1      RJMP	0x06CE
    006FD 9627      ADIW	R28,7
    006FE 9159      LD	R21,Y+
    006FF 9149      LD	R20,Y+
    00700 9508      RET
_thread_main:
  heartBeat_A          --> Y,+6
  heartBeat_B          --> Y,+2
  loopa                --> R20
  loopb                --> R22
    00701 940E 0D23 CALL	push_xgsetF000
    00703 972A      SBIW	R28,0xA
(0249) 	}
(0250) }
(0251) 
(0252) void thread_main(void){
(0253) 
(0254) 	 uchar loopa,loopb;
(0255) 	 
(0256) 	 unsigned long  heartBeat_A,heartBeat_B;
(0257) 	 
(0258) 	 heartBeat_A = heartBeat_B = 0;
    00704 E080      LDI	R24,0
    00705 838A      STD	Y+2,R24
    00706 838B      STD	Y+3,R24
    00707 838C      STD	Y+4,R24
    00708 838D      STD	Y+5,R24
    00709 E080      LDI	R24,0
    0070A 838E      STD	Y+6,R24
    0070B 838F      STD	Y+7,R24
    0070C 8788      STD	Y+8,R24
    0070D 8789      STD	Y+9,R24
    0070E C379      RJMP	0x0A88
(0259) 
(0260) 	 while(1){
(0261) 	 
(0262) 	 /*********************************************PROCESSING_WIFI*********************************************/
(0263) 		 
(0264) 		 //putchar0(0x30+strcmp(userMe_temp.userID,userMe.userID));				//用户名比较结果测试
(0265) 		 //putchar0(0x30+strcmp(userMe_temp.password,userMe.password));			//密码比较结果测试
(0266) 		 
(0267) 		 if(WIFI_BUF[0] == 0x5a){				//包头解析
    0070F 9180 05C2 LDS	R24,UART1_RxBuff_Queue
    00711 358A      CPI	R24,0x5A
    00712 F009      BEQ	0x0714
    00713 C118      RJMP	0x082C
(0268) 		 
(0269) 		 	 if((WIFI_BUF[1] == device_ID) || (WIFI_BUF[1] == 0x06)){
    00714 9180 05C3 LDS	R24,UART1_RxBuff_Queue+1
    00716 3085      CPI	R24,5
    00717 F019      BEQ	0x071B
    00718 3086      CPI	R24,6
    00719 F009      BEQ	0x071B
    0071A C111      RJMP	0x082C
(0270) 			 
(0271) 			 	 switch(WIFI_BUF[2]){
    0071B 9140 05C4 LDS	R20,UART1_RxBuff_Queue+2
    0071D 2755      CLR	R21
    0071E 3140      CPI	R20,0x10
    0071F E0E0      LDI	R30,0
    00720 075E      CPC	R21,R30
    00721 F1A9      BEQ	0x0757
    00722 E180      LDI	R24,0x10
    00723 E090      LDI	R25,0
    00724 1784      CP	R24,R20
    00725 0795      CPC	R25,R21
    00726 F074      BLT	0x0735
    00727 3041      CPI	R20,1
    00728 E0E0      LDI	R30,0
    00729 075E      CPC	R21,R30
    0072A F081      BEQ	0x073B
    0072B 3042      CPI	R20,2
    0072C E0E0      LDI	R30,0
    0072D 075E      CPC	R21,R30
    0072E F0D1      BEQ	0x0749
    0072F 3043      CPI	R20,3
    00730 E0E0      LDI	R30,0
    00731 075E      CPC	R21,R30
    00732 F409      BNE	0x0734
    00733 C0C1      RJMP	0x07F5
    00734 C0C5      RJMP	0x07FA
    00735 3340      CPI	R20,0x30
    00736 E0E0      LDI	R30,0
    00737 075E      CPC	R21,R30
    00738 F409      BNE	0x073A
    00739 C0AA      RJMP	0x07E4
    0073A C0BF      RJMP	0x07FA
(0272) 				  
(0273) 				  	 case 0x01:		 strcpy(userMe.userID,&(WIFI_BUF[3]));userID_write(userMe.userID);	//老师设置用户名
    0073B EC25      LDI	R18,0xC5
    0073C E035      LDI	R19,5
    0073D E502      LDI	R16,0x52
    0073E E011      LDI	R17,1
    0073F 940E 0CDE CALL	_strcpy
    00741 E502      LDI	R16,0x52
    00742 E011      LDI	R17,1
    00743 DEBD      RCALL	_userID_write
(0274) 					 	  			 ITFR_PUTS("page main");
    00744 E90D      LDI	R16,0x9D
    00745 E012      LDI	R17,2
    00746 940E 031A CALL	_puts0
(0275) 					 	  			 //WIFI_PUTS("userID set");WIFI_PUTS(userMe.userID);		//测试wifi获取老师设置的用户名
(0276) 						  			 break;
    00748 C0B1      RJMP	0x07FA
(0277) 									 
(0278) 					 case 0x02:		 strcpy(userMe.password,&(WIFI_BUF[3]));password_write(userMe.password);	//老师设置密码
    00749 EC25      LDI	R18,0xC5
    0074A E035      LDI	R19,5
    0074B E50B      LDI	R16,0x5B
    0074C E011      LDI	R17,1
    0074D 940E 0CDE CALL	_strcpy
    0074F E50B      LDI	R16,0x5B
    00750 E011      LDI	R17,1
    00751 DED3      RCALL	_password_write
(0279) 					 	  			 ITFR_PUTS("page main");
    00752 E90D      LDI	R16,0x9D
    00753 E012      LDI	R17,2
    00754 940E 031A CALL	_puts0
(0280) 					 	  			 //WIFI_PUTS("password set");WIFI_PUTS(userMe.password);	//测试测试wifi获取老师设置的密码
(0281) 									 break;
    00756 C0A3      RJMP	0x07FA
(0282) 									 
(0283) 					 case 0x10:		 IOReinstate();			   									//避免重复设故，以最后一次为准，将上一次复位
    00757 940E 0B26 CALL	_IOReinstate
(0284) 					 	  			 ITFR_PUTS("device_select.dfs.txt=\"0\"");
    00759 E601      LDI	R16,0x61
    0075A E012      LDI	R17,2
    0075B 940E 031A CALL	_puts0
(0285) 									 ITFR_PUTS("device_select.dfb.txt=\"0\"");
    0075D E407      LDI	R16,0x47
    0075E E012      LDI	R17,2
    0075F 940E 031A CALL	_puts0
(0286) 									 ITFR_PUTS("device_select.wbl.txt=\"0\"");
    00761 E20D      LDI	R16,0x2D
    00762 E012      LDI	R17,2
    00763 940E 031A CALL	_puts0
(0287) 									 ITFR_PUTS("device_select.xdg.txt=\"0\"");
    00765 E103      LDI	R16,0x13
    00766 E012      LDI	R17,2
    00767 940E 031A CALL	_puts0
(0288) 									 ITFR_PUTS("device_select.xyj.txt=\"0\"");
    00769 EF09      LDI	R16,0xF9
    0076A E011      LDI	R17,1
    0076B 940E 031A CALL	_puts0
(0289) 									 
(0290) 					 	  			 for(loopa = 3;loopa < 17;loopa ++){						//老师设故解析,注意此处字节数有限制
    0076D E043      LDI	R20,3
    0076E C065      RJMP	0x07D4
(0291) 					 
(0292) 					 	  			 	switch(WIFI_BUF[loopa]){   								//设故板响应，设定成老师设故要求
    0076F EC82      LDI	R24,0xC2
    00770 E095      LDI	R25,5
    00771 2FE4      MOV	R30,R20
    00772 27FF      CLR	R31
    00773 0FE8      ADD	R30,R24
    00774 1FF9      ADC	R31,R25
    00775 8160      LD	R22,Z
    00776 2777      CLR	R23
    00777 3061      CPI	R22,1
    00778 E0E0      LDI	R30,0
    00779 077E      CPC	R23,R30
    0077A F40C      BGE	0x077C
    0077B C057      RJMP	0x07D3
    0077C E08E      LDI	R24,0xE
    0077D E090      LDI	R25,0
    0077E 1786      CP	R24,R22
    0077F 0797      CPC	R25,R23
    00780 F40C      BGE	0x0782
    00781 C051      RJMP	0x07D3
    00782 E88C      LDI	R24,0x8C
    00783 E090      LDI	R25,0
    00784 01FB      MOVW	R30,R22
    00785 9731      SBIW	R30,1
    00786 0FEE      LSL	R30
    00787 1FFF      ROL	R31
    00788 0FE8      ADD	R30,R24
    00789 1FF9      ADC	R31,R25
    0078A 9027      ELPM	R2,Z+
    0078B 9036      ELPM	R3,Z
    0078C 01F1      MOVW	R30,R2
    0078D 9409      IJMP
(0293) 					 	  			 					 
(0294) 					 	  			 	 	case  1:	dianfengshan_IO('T',1);	break;
    0078E E021      LDI	R18,1
    0078F E504      LDI	R16,0x54
    00790 940E 0B60 CALL	_dianfengshan_IO
    00792 C040      RJMP	0x07D3
(0295) 										 	case  2:	dianfengshan_IO('T',2); break;
    00793 E022      LDI	R18,2
    00794 E504      LDI	R16,0x54
    00795 940E 0B60 CALL	_dianfengshan_IO
    00797 C03B      RJMP	0x07D3
(0296) 										 	case  3:	dianfengshan_IO('T',3);	break;
    00798 E023      LDI	R18,3
    00799 E504      LDI	R16,0x54
    0079A 940E 0B60 CALL	_dianfengshan_IO
    0079C C036      RJMP	0x07D3
(0297) 										 	case  4:	dianfengshan_IO('T',4);	break;
    0079D E024      LDI	R18,4
    0079E E504      LDI	R16,0x54
    0079F 940E 0B60 CALL	_dianfengshan_IO
    007A1 C031      RJMP	0x07D3
(0298) 										 	case  5:	dianfanbao_IO('T',1);	break;
    007A2 E021      LDI	R18,1
    007A3 E504      LDI	R16,0x54
    007A4 940E 0BB2 CALL	_dianfanbao_IO
    007A6 C02C      RJMP	0x07D3
(0299) 				 	  			 	 	 	case  6:	dianfanbao_IO('T',2);	break;
    007A7 E022      LDI	R18,2
    007A8 E504      LDI	R16,0x54
    007A9 940E 0BB2 CALL	_dianfanbao_IO
    007AB C027      RJMP	0x07D3
(0300) 										 	case  7:	dianfanbao_IO('T',3);	break;
    007AC E023      LDI	R18,3
    007AD E504      LDI	R16,0x54
    007AE 940E 0BB2 CALL	_dianfanbao_IO
    007B0 C022      RJMP	0x07D3
(0301) 										 	case  8:	weibolu_IO('T',1);		break;
    007B1 E021      LDI	R18,1
    007B2 E504      LDI	R16,0x54
    007B3 940E 0BFC CALL	_weibolu_IO
    007B5 C01D      RJMP	0x07D3
(0302) 										 	case  9:	weibolu_IO('T',2);		break;
    007B6 E022      LDI	R18,2
    007B7 E504      LDI	R16,0x54
    007B8 940E 0BFC CALL	_weibolu_IO
    007BA C018      RJMP	0x07D3
(0303) 										 	case 10:	xiaodugui_IO('T',1);	break;
    007BB E021      LDI	R18,1
    007BC E504      LDI	R16,0x54
    007BD 940E 0C36 CALL	_xiaodugui_IO
    007BF C013      RJMP	0x07D3
(0304) 										 	case 11:	xiaodugui_IO('T',2);	break;
    007C0 E022      LDI	R18,2
    007C1 E504      LDI	R16,0x54
    007C2 940E 0C36 CALL	_xiaodugui_IO
    007C4 C00E      RJMP	0x07D3
(0305) 										 	case 12:	xiyiji_IO('T',1);		break;
    007C5 E021      LDI	R18,1
    007C6 E504      LDI	R16,0x54
    007C7 940E 0C70 CALL	_xiyiji_IO
    007C9 C009      RJMP	0x07D3
(0306) 										 	case 13:	xiyiji_IO('T',2);		break;
    007CA E022      LDI	R18,2
    007CB E504      LDI	R16,0x54
    007CC 940E 0C70 CALL	_xiyiji_IO
    007CE C004      RJMP	0x07D3
(0307) 										 	case 14:	xiyiji_IO('T',3);		break;
    007CF E023      LDI	R18,3
    007D0 E504      LDI	R16,0x54
    007D1 940E 0C70 CALL	_xiyiji_IO
    007D3 9543      INC	R20
    007D4 3141      CPI	R20,0x11
    007D5 F408      BCC	0x07D7
    007D6 CF98      RJMP	0x076F
(0308) 											default:	break;
(0309) 					 	  			 	 }
(0310) 					 	  			 }
(0311) 									 WIFI_BUF[1] = device_ID; 					//修改ID，原包返回响应请求
    007D7 E085      LDI	R24,5
    007D8 9380 05C3 STS	UART1_RxBuff_Queue+1,R24
(0312) 				 					 WIFI_PUTS(WIFI_BUF);
    007DA EC02      LDI	R16,0xC2
    007DB E015      LDI	R17,5
    007DC 940E 0330 CALL	_puts1
(0313) 									 
(0314) 									 heartBeat_B = 0;	 						//心跳
    007DE E080      LDI	R24,0
    007DF 838A      STD	Y+2,R24
    007E0 838B      STD	Y+3,R24
    007E1 838C      STD	Y+4,R24
    007E2 838D      STD	Y+5,R24
(0315) 									 
(0316) 									 break;
    007E3 C016      RJMP	0x07FA
(0317) 									 
(0318) 					 case 0x30:		 IOReinstate(); 	 						//设备复位
    007E4 940E 0B26 CALL	_IOReinstate
(0319) 					 	  			 ITFR_PUTS("page device_select");			//重新开放选择界面
    007E6 E70B      LDI	R16,0x7B
    007E7 E012      LDI	R17,2
    007E8 940E 031A CALL	_puts0
(0320) 									 UI_pt = 0x02;
    007EA E082      LDI	R24,2
    007EB 9380 0176 STS	UI_pt,R24
(0321) 					 	  			 WIFI_BUF[1] = device_ID; 		 			//修改ID，原包返回响应请求
    007ED E085      LDI	R24,5
    007EE 9380 05C3 STS	UART1_RxBuff_Queue+1,R24
(0322) 				 					 WIFI_PUTS(WIFI_BUF);
    007F0 EC02      LDI	R16,0xC2
    007F1 E015      LDI	R17,5
    007F2 940E 0330 CALL	_puts1
(0323) 					 	  			 break;
    007F4 C005      RJMP	0x07FA
(0324) 									 
(0325) 					 case 0x03:		 heartBeat_B = 0; 		 					//确认连接，心跳标记清零
    007F5 E080      LDI	R24,0
    007F6 838A      STD	Y+2,R24
    007F7 838B      STD	Y+3,R24
    007F8 838C      STD	Y+4,R24
    007F9 838D      STD	Y+5,R24
(0326) 					 	  			 break;
(0327) 									 
(0328) 					 default:		 break;
(0329) 				 }
(0330) 				 
(0331) 		 		 if(infoMal_teacher.dianfengshan)ITFR_PUTS("device_select.dfs.txt=\"1\"");	//解冻设备选项				 
    007FA 9020 05AF LDS	R2,infoMal_teacher
    007FC 2022      TST	R2
    007FD F021      BEQ	0x0802
    007FE ED0F      LDI	R16,0xDF
    007FF E011      LDI	R17,1
    00800 940E 031A CALL	_puts0
(0332) 				 if(infoMal_teacher.dianfanbao)ITFR_PUTS("device_select.dfb.txt=\"1\"");
    00802 9020 05B0 LDS	R2,infoMal_teacher+1
    00804 2022      TST	R2
    00805 F021      BEQ	0x080A
    00806 EC05      LDI	R16,0xC5
    00807 E011      LDI	R17,1
    00808 940E 031A CALL	_puts0
(0333) 				 if(infoMal_teacher.weibolu)ITFR_PUTS("device_select.wbl.txt=\"1\"");
    0080A 9020 05B1 LDS	R2,infoMal_teacher+2
    0080C 2022      TST	R2
    0080D F021      BEQ	0x0812
    0080E EA0B      LDI	R16,0xAB
    0080F E011      LDI	R17,1
    00810 940E 031A CALL	_puts0
(0334) 				 if(infoMal_teacher.xiaodugui)ITFR_PUTS("device_select.xdg.txt=\"1\"");
    00812 9020 05B2 LDS	R2,infoMal_teacher+3
    00814 2022      TST	R2
    00815 F021      BEQ	0x081A
    00816 E901      LDI	R16,0x91
    00817 E011      LDI	R17,1
    00818 940E 031A CALL	_puts0
(0335) 				 if(infoMal_teacher.xiyiji)ITFR_PUTS("device_select.xyj.txt=\"1\"");
    0081A 9020 05B3 LDS	R2,infoMal_teacher+4
    0081C 2022      TST	R2
    0081D F021      BEQ	0x0822
    0081E E707      LDI	R16,0x77
    0081F E011      LDI	R17,1
    00820 940E 031A CALL	_puts0
(0336) 			 	 memset(WIFI_BUF,0,sizeof(uchar)*UART0_RX_BUFFER_SIZE);
    00822 E18E      LDI	R24,0x1E
    00823 E090      LDI	R25,0
    00824 8399      STD	Y+1,R25
    00825 8388      ST	Y,R24
    00826 2722      CLR	R18
    00827 2733      CLR	R19
    00828 EC02      LDI	R16,0xC2
    00829 E015      LDI	R17,5
    0082A 940E 0CC6 CALL	_memset
(0337) 			 }
(0338) 		 }
(0339) 		 //delay_ms(1500);			//测试延时
(0340) 		 //WIFI_PUTS(WIFI_BUF);		//测试WIFI缓存
(0341) 		 
(0342) 		 
(0343) 	  /*********************************************PROCESSING_ITFR*********************************************/
(0344) 
(0345) 		 if(ITFR_BUF[0] == 0x5a){		//包头解析
    0082C 9180 0658 LDS	R24,UART0_RxBuff_Queue
    0082E 358A      CPI	R24,0x5A
    0082F F009      BEQ	0x0831
    00830 C20C      RJMP	0x0A3D
(0346) 		 
(0347) 		 	 switch(ITFR_BUF[1]){
    00831 9160 0659 LDS	R22,UART0_RxBuff_Queue+1
    00833 2777      CLR	R23
    00834 3260      CPI	R22,0x20
    00835 E0E0      LDI	R30,0
    00836 077E      CPC	R23,R30
    00837 F409      BNE	0x0839
    00838 C08F      RJMP	0x08C8
    00839 E280      LDI	R24,0x20
    0083A E090      LDI	R25,0
    0083B 1786      CP	R24,R22
    0083C 0797      CPC	R25,R23
    0083D F0BC      BLT	0x0855
    0083E 3061      CPI	R22,1
    0083F E0E0      LDI	R30,0
    00840 077E      CPC	R23,R30
    00841 F149      BEQ	0x086B
    00842 3062      CPI	R22,2
    00843 E0E0      LDI	R30,0
    00844 077E      CPC	R23,R30
    00845 F161      BEQ	0x0872
    00846 3061      CPI	R22,1
    00847 E0E0      LDI	R30,0
    00848 077E      CPC	R23,R30
    00849 F40C      BGE	0x084B
    0084A C1BB      RJMP	0x0A06
    0084B 306F      CPI	R22,0xF
    0084C E0E0      LDI	R30,0
    0084D 077E      CPC	R23,R30
    0084E F409      BNE	0x0850
    0084F C1B4      RJMP	0x0A04
    00850 3160      CPI	R22,0x10
    00851 E0E0      LDI	R30,0
    00852 077E      CPC	R23,R30
    00853 F129      BEQ	0x0879
    00854 C1B1      RJMP	0x0A06
    00855 3460      CPI	R22,0x40
    00856 E0E0      LDI	R30,0
    00857 077E      CPC	R23,R30
    00858 F409      BNE	0x085A
    00859 C10C      RJMP	0x0966
    0085A E480      LDI	R24,0x40
    0085B E090      LDI	R25,0
    0085C 1786      CP	R24,R22
    0085D 0797      CPC	R25,R23
    0085E F034      BLT	0x0865
    0085F 3360      CPI	R22,0x30
    00860 E0E0      LDI	R30,0
    00861 077E      CPC	R23,R30
    00862 F409      BNE	0x0864
    00863 C0B3      RJMP	0x0917
    00864 C1A1      RJMP	0x0A06
    00865 3560      CPI	R22,0x50
    00866 E0E0      LDI	R30,0
    00867 077E      CPC	R23,R30
    00868 F409      BNE	0x086A
    00869 C14B      RJMP	0x09B5
    0086A C19B      RJMP	0x0A06
(0348) 			 
(0349) 			 	  	case 0x01:		strcpy(userMe_temp.userID,&(ITFR_BUF[2]));							//学生输入用户名
    0086B E52A      LDI	R18,0x5A
    0086C E036      LDI	R19,6
    0086D E604      LDI	R16,0x64
    0086E E011      LDI	R17,1
    0086F 940E 0CDE CALL	_strcpy
(0350) 						 			//ITFR_PUTS("GOT userID");ITFR_PUTS(userMe_temp.userID);			//测试学生输入的用户名
(0351) 						  			break;
    00871 C194      RJMP	0x0A06
(0352) 					case 0x02:		strcpy(userMe_temp.password,&(ITFR_BUF[2]));						//学生输入密码
    00872 E52A      LDI	R18,0x5A
    00873 E036      LDI	R19,6
    00874 E60D      LDI	R16,0x6D
    00875 E011      LDI	R17,1
    00876 940E 0CDE CALL	_strcpy
(0353) 						 			//ITFR_PUTS("GOT password set");ITFR_PUTS(userMe_temp.password);	//测试学生输入的密码
(0354) 						 			break;
    00878 C18D      RJMP	0x0A06
(0355) 									
(0356) 					case 0x10:		for(loopa = 0;loopa < 4;loopa ++)										   //学生提交解故结果解析，电分扇，4个设故点
    00879 2744      CLR	R20
    0087A C00F      RJMP	0x088A
(0357) 						 				if(ITFR_BUF[loopa+2] == '1')dianfengshan_IO('S',loopa+1);			   //设故板响应，设定成学生提交结果
    0087B E58A      LDI	R24,0x5A
    0087C E096      LDI	R25,6
    0087D 2FE4      MOV	R30,R20
    0087E 27FF      CLR	R31
    0087F 0FE8      ADD	R30,R24
    00880 1FF9      ADC	R31,R25
    00881 8180      LD	R24,Z
    00882 3381      CPI	R24,0x31
    00883 F429      BNE	0x0889
    00884 2F24      MOV	R18,R20
    00885 5F2F      SUBI	R18,0xFF
    00886 E503      LDI	R16,0x53
    00887 940E 0B60 CALL	_dianfengshan_IO
    00889 9543      INC	R20
    0088A 3044      CPI	R20,4
    0088B F378      BCS	0x087B
(0358) 										
(0359) 									OPJudje(infoMal_teacher.dianfengshan,infoMal_student.dianfengshan,1); 	   //比较学生提交结果与老是设定，得到仲裁结果		
    0088C E081      LDI	R24,1
    0088D 8388      ST	Y,R24
    0088E 9120 05B4 LDS	R18,infoMal_student
    00890 9100 05AF LDS	R16,infoMal_teacher
    00892 940E 0B3C CALL	_OPJudje
(0360) 									for(loopa = 0;loopa < 4;loopa ++)										   //每一位都比较，避免游标错位
    00894 2744      CLR	R20
    00895 C01D      RJMP	0x08B3
(0361) 									    for(loopb = 1;loopb <= 4;loopb ++)		  							   //向本地用户提交仲裁结果，只提交错误信息，loopb游标从1-4，表示故障1-4为电风扇故障
    00896 E061      LDI	R22,1
    00897 C017      RJMP	0x08AF
(0362) 										    if(resIOJudge[loopa] == loopb)ITFR_PUTS((char*)ITFR_CMD[loopb-1]); //向本地用户提交结果，只提交错误的设故标号，[loopb-1]为故障标号与数组索引差值
    00898 EB89      LDI	R24,0xB9
    00899 E095      LDI	R25,5
    0089A 2FE4      MOV	R30,R20
    0089B 27FF      CLR	R31
    0089C 0FE8      ADD	R30,R24
    0089D 1FF9      ADC	R31,R25
    0089E 8020      LD	R2,Z
    0089F 1626      CP	R2,R22
    008A0 F469      BNE	0x08AE
    008A1 E08C      LDI	R24,0xC
    008A2 E091      LDI	R25,1
    008A3 2FE6      MOV	R30,R22
    008A4 27FF      CLR	R31
    008A5 9731      SBIW	R30,1
    008A6 0FEE      LSL	R30
    008A7 1FFF      ROL	R31
    008A8 0FE8      ADD	R30,R24
    008A9 1FF9      ADC	R31,R25
    008AA 8100      LD	R16,Z
    008AB 8111      LDD	R17,Z+1
    008AC 940E 031A CALL	_puts0
    008AE 9563      INC	R22
    008AF E084      LDI	R24,4
    008B0 1786      CP	R24,R22
    008B1 F730      BCC	0x0898
    008B2 9543      INC	R20
    008B3 3044      CPI	R20,4
    008B4 F308      BCS	0x0896
(0363) 									
(0364) 									memset(resIOJudge,0,sizeof(uchar)*9);		  //清除比较信息结果缓存
    008B5 E089      LDI	R24,0x9
    008B6 E090      LDI	R25,0
    008B7 8399      STD	Y+1,R25
    008B8 8388      ST	Y,R24
    008B9 2722      CLR	R18
    008BA 2733      CLR	R19
    008BB EB09      LDI	R16,0xB9
    008BC E015      LDI	R17,5
    008BD 940E 0CC6 CALL	_memset
(0365) 									OPJudje(0x00,infoMal_student.dianfengshan,1); //得到学生更改变动的故障对应的故障编号信息，不仲裁
    008BF E081      LDI	R24,1
    008C0 8388      ST	Y,R24
    008C1 9120 05B4 LDS	R18,infoMal_student
    008C3 2700      CLR	R16
    008C4 940E 0B3C CALL	_OPJudje
(0366) 									reaptRes();				//学生变动提交老师
    008C6 DD70      RCALL	_reaptRes
(0367) 										
(0368) 									break;
    008C7 C13E      RJMP	0x0A06
(0369) 									
(0370) 					case 0x20:		for(loopa = 0;loopa < 2;loopa ++)		  						//微波炉，2个设故点
    008C8 2744      CLR	R20
    008C9 C00F      RJMP	0x08D9
(0371) 						 				if(ITFR_BUF[loopa+2] == '1')weibolu_IO('S',loopa+1);		//loop+2为了跳过包头两个字节
    008CA E58A      LDI	R24,0x5A
    008CB E096      LDI	R25,6
    008CC 2FE4      MOV	R30,R20
    008CD 27FF      CLR	R31
    008CE 0FE8      ADD	R30,R24
    008CF 1FF9      ADC	R31,R25
    008D0 8180      LD	R24,Z
    008D1 3381      CPI	R24,0x31
    008D2 F429      BNE	0x08D8
    008D3 2F24      MOV	R18,R20
    008D4 5F2F      SUBI	R18,0xFF
    008D5 E503      LDI	R16,0x53
    008D6 940E 0BFC CALL	_weibolu_IO
    008D8 9543      INC	R20
    008D9 3042      CPI	R20,2
    008DA F378      BCS	0x08CA
(0372) 										
(0373) 									OPJudje(infoMal_teacher.weibolu,infoMal_student.weibolu,8);		
    008DB E088      LDI	R24,0x8
    008DC 8388      ST	Y,R24
    008DD 9120 05B6 LDS	R18,infoMal_student+2
    008DF 9100 05B1 LDS	R16,infoMal_teacher+2
    008E1 940E 0B3C CALL	_OPJudje
(0374) 									for(loopa = 0;loopa < 2;loopa ++)				
    008E3 2744      CLR	R20
    008E4 C01D      RJMP	0x0902
(0375) 									    for(loopb = 8;loopb <= 9;loopb ++)										//8-9
    008E5 E068      LDI	R22,0x8
    008E6 C017      RJMP	0x08FE
(0376) 										    if(resIOJudge[loopa] == loopb)ITFR_PUTS((char*)ITFR_CMD[loopb-1]);
    008E7 EB89      LDI	R24,0xB9
    008E8 E095      LDI	R25,5
    008E9 2FE4      MOV	R30,R20
    008EA 27FF      CLR	R31
    008EB 0FE8      ADD	R30,R24
    008EC 1FF9      ADC	R31,R25
    008ED 8020      LD	R2,Z
    008EE 1626      CP	R2,R22
    008EF F469      BNE	0x08FD
    008F0 E08C      LDI	R24,0xC
    008F1 E091      LDI	R25,1
    008F2 2FE6      MOV	R30,R22
    008F3 27FF      CLR	R31
    008F4 9731      SBIW	R30,1
    008F5 0FEE      LSL	R30
    008F6 1FFF      ROL	R31
    008F7 0FE8      ADD	R30,R24
    008F8 1FF9      ADC	R31,R25
    008F9 8100      LD	R16,Z
    008FA 8111      LDD	R17,Z+1
    008FB 940E 031A CALL	_puts0
    008FD 9563      INC	R22
    008FE E089      LDI	R24,0x9
    008FF 1786      CP	R24,R22
    00900 F730      BCC	0x08E7
    00901 9543      INC	R20
    00902 3042      CPI	R20,2
    00903 F308      BCS	0x08E5
(0377) 										
(0378) 									memset(resIOJudge,0,sizeof(uchar)*9);
    00904 E089      LDI	R24,0x9
    00905 E090      LDI	R25,0
    00906 8399      STD	Y+1,R25
    00907 8388      ST	Y,R24
    00908 2722      CLR	R18
    00909 2733      CLR	R19
    0090A EB09      LDI	R16,0xB9
    0090B E015      LDI	R17,5
    0090C 940E 0CC6 CALL	_memset
(0379) 									OPJudje(0x00,infoMal_student.weibolu,8);
    0090E E088      LDI	R24,0x8
    0090F 8388      ST	Y,R24
    00910 9120 05B6 LDS	R18,infoMal_student+2
    00912 2700      CLR	R16
    00913 940E 0B3C CALL	_OPJudje
(0380) 									reaptRes();
    00915 DD21      RCALL	_reaptRes
(0381) 																		
(0382) 									break;	
    00916 C0EF      RJMP	0x0A06
(0383) 									
(0384) 					case 0x30:		for(loopa = 0;loopa < 3;loopa ++)						   		 //电饭煲，3个设故点
    00917 2744      CLR	R20
    00918 C00F      RJMP	0x0928
(0385) 						 				if(ITFR_BUF[loopa+2] == '1')dianfanbao_IO('S',loopa+1);
    00919 E58A      LDI	R24,0x5A
    0091A E096      LDI	R25,6
    0091B 2FE4      MOV	R30,R20
    0091C 27FF      CLR	R31
    0091D 0FE8      ADD	R30,R24
    0091E 1FF9      ADC	R31,R25
    0091F 8180      LD	R24,Z
    00920 3381      CPI	R24,0x31
    00921 F429      BNE	0x0927
    00922 2F24      MOV	R18,R20
    00923 5F2F      SUBI	R18,0xFF
    00924 E503      LDI	R16,0x53
    00925 940E 0BB2 CALL	_dianfanbao_IO
    00927 9543      INC	R20
    00928 3043      CPI	R20,3
    00929 F378      BCS	0x0919
(0386) 										
(0387) 									OPJudje(infoMal_teacher.dianfanbao,infoMal_student.dianfanbao,5);	
    0092A E085      LDI	R24,5
    0092B 8388      ST	Y,R24
    0092C 9120 05B5 LDS	R18,infoMal_student+1
    0092E 9100 05B0 LDS	R16,infoMal_teacher+1
    00930 940E 0B3C CALL	_OPJudje
(0388) 									for(loopa = 0;loopa < 3;loopa ++)							
    00932 2744      CLR	R20
    00933 C01D      RJMP	0x0951
(0389) 									    for(loopb = 5;loopb <= 7;loopb ++)										//5-7
    00934 E065      LDI	R22,5
    00935 C017      RJMP	0x094D
(0390) 										    if(resIOJudge[loopa] == loopb)ITFR_PUTS((char*)ITFR_CMD[loopb-1]);
    00936 EB89      LDI	R24,0xB9
    00937 E095      LDI	R25,5
    00938 2FE4      MOV	R30,R20
    00939 27FF      CLR	R31
    0093A 0FE8      ADD	R30,R24
    0093B 1FF9      ADC	R31,R25
    0093C 8020      LD	R2,Z
    0093D 1626      CP	R2,R22
    0093E F469      BNE	0x094C
    0093F E08C      LDI	R24,0xC
    00940 E091      LDI	R25,1
    00941 2FE6      MOV	R30,R22
    00942 27FF      CLR	R31
    00943 9731      SBIW	R30,1
    00944 0FEE      LSL	R30
    00945 1FFF      ROL	R31
    00946 0FE8      ADD	R30,R24
    00947 1FF9      ADC	R31,R25
    00948 8100      LD	R16,Z
    00949 8111      LDD	R17,Z+1
    0094A 940E 031A CALL	_puts0
    0094C 9563      INC	R22
    0094D E087      LDI	R24,7
    0094E 1786      CP	R24,R22
    0094F F730      BCC	0x0936
    00950 9543      INC	R20
    00951 3043      CPI	R20,3
    00952 F308      BCS	0x0934
(0391) 									
(0392) 									memset(resIOJudge,0,sizeof(uchar)*9);	
    00953 E089      LDI	R24,0x9
    00954 E090      LDI	R25,0
    00955 8399      STD	Y+1,R25
    00956 8388      ST	Y,R24
    00957 2722      CLR	R18
    00958 2733      CLR	R19
    00959 EB09      LDI	R16,0xB9
    0095A E015      LDI	R17,5
    0095B 940E 0CC6 CALL	_memset
(0393) 									OPJudje(0x00,infoMal_student.dianfanbao,5);
    0095D E085      LDI	R24,5
    0095E 8388      ST	Y,R24
    0095F 9120 05B5 LDS	R18,infoMal_student+1
    00961 2700      CLR	R16
    00962 940E 0B3C CALL	_OPJudje
(0394) 									reaptRes();
    00964 DCD2      RCALL	_reaptRes
(0395) 				
(0396) 									break;
    00965 C0A0      RJMP	0x0A06
(0397) 									
(0398) 					case 0x40:		for(loopa = 0;loopa < 3;loopa ++)								 //洗衣机，3个设故点
    00966 2744      CLR	R20
    00967 C00F      RJMP	0x0977
(0399) 						 				if(ITFR_BUF[loopa+2] == '1')xiyiji_IO('S',loopa+1);
    00968 E58A      LDI	R24,0x5A
    00969 E096      LDI	R25,6
    0096A 2FE4      MOV	R30,R20
    0096B 27FF      CLR	R31
    0096C 0FE8      ADD	R30,R24
    0096D 1FF9      ADC	R31,R25
    0096E 8180      LD	R24,Z
    0096F 3381      CPI	R24,0x31
    00970 F429      BNE	0x0976
    00971 2F24      MOV	R18,R20
    00972 5F2F      SUBI	R18,0xFF
    00973 E503      LDI	R16,0x53
    00974 940E 0C70 CALL	_xiyiji_IO
    00976 9543      INC	R20
    00977 3043      CPI	R20,3
    00978 F378      BCS	0x0968
(0400) 										
(0401) 									OPJudje(infoMal_teacher.xiyiji,infoMal_student.xiyiji,12);		
    00979 E08C      LDI	R24,0xC
    0097A 8388      ST	Y,R24
    0097B 9120 05B8 LDS	R18,infoMal_student+4
    0097D 9100 05B3 LDS	R16,infoMal_teacher+4
    0097F 940E 0B3C CALL	_OPJudje
(0402) 									for(loopa = 0;loopa < 3;loopa ++)								
    00981 2744      CLR	R20
    00982 C01D      RJMP	0x09A0
(0403) 									    for(loopb = 12;loopb <= 14;loopb ++)									//12-14
    00983 E06C      LDI	R22,0xC
    00984 C017      RJMP	0x099C
(0404) 										    if(resIOJudge[loopa] == loopb)ITFR_PUTS((char*)ITFR_CMD[loopb-1]);
    00985 EB89      LDI	R24,0xB9
    00986 E095      LDI	R25,5
    00987 2FE4      MOV	R30,R20
    00988 27FF      CLR	R31
    00989 0FE8      ADD	R30,R24
    0098A 1FF9      ADC	R31,R25
    0098B 8020      LD	R2,Z
    0098C 1626      CP	R2,R22
    0098D F469      BNE	0x099B
    0098E E08C      LDI	R24,0xC
    0098F E091      LDI	R25,1
    00990 2FE6      MOV	R30,R22
    00991 27FF      CLR	R31
    00992 9731      SBIW	R30,1
    00993 0FEE      LSL	R30
    00994 1FFF      ROL	R31
    00995 0FE8      ADD	R30,R24
    00996 1FF9      ADC	R31,R25
    00997 8100      LD	R16,Z
    00998 8111      LDD	R17,Z+1
    00999 940E 031A CALL	_puts0
    0099B 9563      INC	R22
    0099C E08E      LDI	R24,0xE
    0099D 1786      CP	R24,R22
    0099E F730      BCC	0x0985
    0099F 9543      INC	R20
    009A0 3043      CPI	R20,3
    009A1 F308      BCS	0x0983
(0405) 										
(0406) 									memset(resIOJudge,0,sizeof(uchar)*9);
    009A2 E089      LDI	R24,0x9
    009A3 E090      LDI	R25,0
    009A4 8399      STD	Y+1,R25
    009A5 8388      ST	Y,R24
    009A6 2722      CLR	R18
    009A7 2733      CLR	R19
    009A8 EB09      LDI	R16,0xB9
    009A9 E015      LDI	R17,5
    009AA 940E 0CC6 CALL	_memset
(0407) 									OPJudje(0x00,infoMal_student.xiyiji,12);
    009AC E08C      LDI	R24,0xC
    009AD 8388      ST	Y,R24
    009AE 9120 05B8 LDS	R18,infoMal_student+4
    009B0 2700      CLR	R16
    009B1 940E 0B3C CALL	_OPJudje
(0408) 									reaptRes();
    009B3 DC83      RCALL	_reaptRes
(0409) 									
(0410) 									break;
    009B4 C051      RJMP	0x0A06
(0411) 									
(0412) 					case 0x50:		for(loopa = 0;loopa < 2;loopa ++)						  		 //消毒柜，2个设故点
    009B5 2744      CLR	R20
    009B6 C00F      RJMP	0x09C6
(0413) 						 				if(ITFR_BUF[loopa+2] == '1')xiaodugui_IO('S',loopa+1);
    009B7 E58A      LDI	R24,0x5A
    009B8 E096      LDI	R25,6
    009B9 2FE4      MOV	R30,R20
    009BA 27FF      CLR	R31
    009BB 0FE8      ADD	R30,R24
    009BC 1FF9      ADC	R31,R25
    009BD 8180      LD	R24,Z
    009BE 3381      CPI	R24,0x31
    009BF F429      BNE	0x09C5
    009C0 2F24      MOV	R18,R20
    009C1 5F2F      SUBI	R18,0xFF
    009C2 E503      LDI	R16,0x53
    009C3 940E 0C36 CALL	_xiaodugui_IO
    009C5 9543      INC	R20
    009C6 3042      CPI	R20,2
    009C7 F378      BCS	0x09B7
(0414) 										
(0415) 									OPJudje(infoMal_teacher.xiaodugui,infoMal_student.xiaodugui,10);		
    009C8 E08A      LDI	R24,0xA
    009C9 8388      ST	Y,R24
    009CA 9120 05B7 LDS	R18,infoMal_student+3
    009CC 9100 05B2 LDS	R16,infoMal_teacher+3
    009CE 940E 0B3C CALL	_OPJudje
(0416) 									for(loopa = 0;loopa < 2;loopa ++)				
    009D0 2744      CLR	R20
    009D1 C01D      RJMP	0x09EF
(0417) 										for(loopb = 10;loopb <= 11;loopb ++)									//10-11
    009D2 E06A      LDI	R22,0xA
    009D3 C017      RJMP	0x09EB
(0418) 											if(resIOJudge[loopa] == loopb)ITFR_PUTS((char*)ITFR_CMD[loopb-1]);
    009D4 EB89      LDI	R24,0xB9
    009D5 E095      LDI	R25,5
    009D6 2FE4      MOV	R30,R20
    009D7 27FF      CLR	R31
    009D8 0FE8      ADD	R30,R24
    009D9 1FF9      ADC	R31,R25
    009DA 8020      LD	R2,Z
    009DB 1626      CP	R2,R22
    009DC F469      BNE	0x09EA
    009DD E08C      LDI	R24,0xC
    009DE E091      LDI	R25,1
    009DF 2FE6      MOV	R30,R22
    009E0 27FF      CLR	R31
    009E1 9731      SBIW	R30,1
    009E2 0FEE      LSL	R30
    009E3 1FFF      ROL	R31
    009E4 0FE8      ADD	R30,R24
    009E5 1FF9      ADC	R31,R25
    009E6 8100      LD	R16,Z
    009E7 8111      LDD	R17,Z+1
    009E8 940E 031A CALL	_puts0
    009EA 9563      INC	R22
    009EB E08B      LDI	R24,0xB
    009EC 1786      CP	R24,R22
    009ED F730      BCC	0x09D4
    009EE 9543      INC	R20
    009EF 3042      CPI	R20,2
    009F0 F308      BCS	0x09D2
(0419) 										
(0420) 									memset(resIOJudge,0,sizeof(uchar)*9);
    009F1 E089      LDI	R24,0x9
    009F2 E090      LDI	R25,0
    009F3 8399      STD	Y+1,R25
    009F4 8388      ST	Y,R24
    009F5 2722      CLR	R18
    009F6 2733      CLR	R19
    009F7 EB09      LDI	R16,0xB9
    009F8 E015      LDI	R17,5
    009F9 940E 0CC6 CALL	_memset
(0421) 									OPJudje(0x00,infoMal_student.xiaodugui,10);
    009FB E08A      LDI	R24,0xA
    009FC 8388      ST	Y,R24
    009FD 9120 05B7 LDS	R18,infoMal_student+3
    009FF 2700      CLR	R16
    00A00 940E 0B3C CALL	_OPJudje
(0422) 									reaptRes();
    00A02 DC34      RCALL	_reaptRes
(0423) 
(0424) 									//ITFR_PUTS("Result xiaodugui hand up");		//测试输出
(0425) 									//putchar1(resIOJudge[0]+0x30);	   				//测试比较结果输出
(0426) 									//putchar1(resIOJudge[1]+0x30);
(0427) 									//putchar1(resIOJudge[2]+0x30);
(0428) 									//putchar1(resIOJudge[3]+0x30);
(0429) 									//putchar1(resIOJudge[6]+0x30);
(0430) 									//putchar1(resIOJudge[7]+0x30);
(0431) 									//putchar1(resIOJudge[8]+0x30);										
(0432) 									break;
    00A03 C002      RJMP	0x0A06
(0433) 									
(0434) 					case 0x0f:		IOReinstate();									//结果提交完成，设备复位后重新开放选择界面
    00A04 940E 0B26 CALL	_IOReinstate
(0435) 						 			//ITFR_PUTS("device_select.dfs.txt=\"0\"");		//冰封所有选项，等待老师重新设故
(0436) 									//ITFR_PUTS("device_select.wbl.txt=\"0\"");
(0437) 									//ITFR_PUTS("device_select.dfb.txt=\"0\"");
(0438) 									//ITFR_PUTS("device_select.xyj.txt=\"0\"");
(0439) 									//ITFR_PUTS("device_select.xdg.txt=\"0\"");								
(0440) 						 			//ITFR_PUTS("page device_select");				//开放设故选择界面
(0441) 									
(0442) 					default:		break;
(0443) 			 }
(0444) 			 
(0445) 			 if(!strcmp(userMe_temp.userID,userMe.userID) && !strcmp(userMe_temp.password,userMe.password)){	//用户名及密码验证
    00A06 E522      LDI	R18,0x52
    00A07 E031      LDI	R19,1
    00A08 E604      LDI	R16,0x64
    00A09 E011      LDI	R17,1
    00A0A 940E 0CD1 CALL	_strcmp
    00A0C 3000      CPI	R16,0
    00A0D 0701      CPC	R16,R17
    00A0E F481      BNE	0x0A1F
    00A0F E52B      LDI	R18,0x5B
    00A10 E031      LDI	R19,1
    00A11 E60D      LDI	R16,0x6D
    00A12 E011      LDI	R17,1
    00A13 940E 0CD1 CALL	_strcmp
    00A15 3000      CPI	R16,0
    00A16 0701      CPC	R16,R17
    00A17 F439      BNE	0x0A1F
(0446) 		 			
(0447) 		 			ITFR_PUTS("page device_select");	//开放设故选择界面
    00A18 E70B      LDI	R16,0x7B
    00A19 E012      LDI	R17,2
    00A1A 940E 031A CALL	_puts0
(0448) 					UI_pt = 0x02;
    00A1C E082      LDI	R24,2
    00A1D 9380 0176 STS	UI_pt,R24
(0449) 		 	 }
(0450) 		 	 memset(ITFR_BUF,0,sizeof(uchar)*UART1_RX_BUFFER_SIZE);		  //屏幕处理缓存清空
    00A1F E18E      LDI	R24,0x1E
    00A20 E090      LDI	R25,0
    00A21 8399      STD	Y+1,R25
    00A22 8388      ST	Y,R24
    00A23 2722      CLR	R18
    00A24 2733      CLR	R19
    00A25 E508      LDI	R16,0x58
    00A26 E016      LDI	R17,6
    00A27 940E 0CC6 CALL	_memset
(0451) 			 memset(userMe_temp.password,0,sizeof(uchar)*9);			  //用户输入密码清空
    00A29 E089      LDI	R24,0x9
    00A2A E090      LDI	R25,0
    00A2B 8399      STD	Y+1,R25
    00A2C 8388      ST	Y,R24
    00A2D 2722      CLR	R18
    00A2E 2733      CLR	R19
    00A2F E60D      LDI	R16,0x6D
    00A30 E011      LDI	R17,1
    00A31 940E 0CC6 CALL	_memset
(0452) 		 	 memset(resIOJudge,0,sizeof(uchar)*9);						  //学生提交与老师设故仲裁结果清空
    00A33 E089      LDI	R24,0x9
    00A34 E090      LDI	R25,0
    00A35 8399      STD	Y+1,R25
    00A36 8388      ST	Y,R24
    00A37 2722      CLR	R18
    00A38 2733      CLR	R19
    00A39 EB09      LDI	R16,0xB9
    00A3A E015      LDI	R17,5
    00A3B 940E 0CC6 CALL	_memset
(0453) 		}
(0454) 		
(0455) 	  /*********************************************PROCESSING_HEARTBEAT*******************************************/
(0456) 	  	if(heartBeat_A > 300000){					//周期发送心跳包
    00A3D EE80      LDI	R24,0xE0
    00A3E E993      LDI	R25,0x93
    00A3F E0A4      LDI	R26,4
    00A40 E0B0      LDI	R27,0
    00A41 802E      LDD	R2,Y+6
    00A42 803F      LDD	R3,Y+7
    00A43 8448      LDD	R4,Y+8
    00A44 8459      LDD	R5,Y+9
    00A45 1582      CP	R24,R2
    00A46 0593      CPC	R25,R3
    00A47 05A4      CPC	R26,R4
    00A48 05B5      CPC	R27,R5
    00A49 F450      BCC	0x0A54
(0457) 		
(0458) 			heartBeat_A = 0;	   
    00A4A E080      LDI	R24,0
    00A4B 838E      STD	Y+6,R24
    00A4C 838F      STD	Y+7,R24
    00A4D 8788      STD	Y+8,R24
    00A4E 8789      STD	Y+9,R24
(0459) 			WIFI_PUTS((char*)cntConfirm);
    00A4F E40A      LDI	R16,0x4A
    00A50 E011      LDI	R17,1
    00A51 940E 0330 CALL	_puts1
(0460) 		}else heartBeat_A ++;
    00A53 C010      RJMP	0x0A64
    00A54 E081      LDI	R24,1
    00A55 E090      LDI	R25,0
    00A56 E0A0      LDI	R26,0
    00A57 E0B0      LDI	R27,0
    00A58 802E      LDD	R2,Y+6
    00A59 803F      LDD	R3,Y+7
    00A5A 8448      LDD	R4,Y+8
    00A5B 8459      LDD	R5,Y+9
    00A5C 0E28      ADD	R2,R24
    00A5D 1E39      ADC	R3,R25
    00A5E 1E4A      ADC	R4,R26
    00A5F 1E5B      ADC	R5,R27
    00A60 822E      STD	Y+6,R2
    00A61 823F      STD	Y+7,R3
    00A62 8648      STD	Y+8,R4
    00A63 8659      STD	Y+9,R5
(0461) 		
(0462) 		if(heartBeat_B > 1000000){		 			//周期接收心跳回复   发三次有一次收到就行
    00A64 E480      LDI	R24,0x40
    00A65 E492      LDI	R25,0x42
    00A66 E0AF      LDI	R26,0xF
    00A67 E0B0      LDI	R27,0
    00A68 802A      LDD	R2,Y+2
    00A69 803B      LDD	R3,Y+3
    00A6A 804C      LDD	R4,Y+4
    00A6B 805D      LDD	R5,Y+5
    00A6C 1582      CP	R24,R2
    00A6D 0593      CPC	R25,R3
    00A6E 05A4      CPC	R26,R4
    00A6F 05B5      CPC	R27,R5
    00A70 F438      BCC	0x0A78
(0463) 			
(0464) 			heartBeat_B = 0;
    00A71 E080      LDI	R24,0
    00A72 838A      STD	Y+2,R24
    00A73 838B      STD	Y+3,R24
    00A74 838C      STD	Y+4,R24
    00A75 838D      STD	Y+5,R24
(0465) 			wifiReconnect();
    00A76 DC4F      RCALL	_wifiReconnect
(0466) 		}else heartBeat_B ++;
    00A77 C010      RJMP	0x0A88
    00A78 E081      LDI	R24,1
    00A79 E090      LDI	R25,0
    00A7A E0A0      LDI	R26,0
    00A7B E0B0      LDI	R27,0
    00A7C 802A      LDD	R2,Y+2
    00A7D 803B      LDD	R3,Y+3
    00A7E 804C      LDD	R4,Y+4
    00A7F 805D      LDD	R5,Y+5
    00A80 0E28      ADD	R2,R24
    00A81 1E39      ADC	R3,R25
    00A82 1E4A      ADC	R4,R26
    00A83 1E5B      ADC	R5,R27
    00A84 822A      STD	Y+2,R2
    00A85 823B      STD	Y+3,R3
    00A86 824C      STD	Y+4,R4
    00A87 825D      STD	Y+5,R5
    00A88 CC86      RJMP	0x070F
    00A89 962A      ADIW	R28,0xA
    00A8A 940C 0D28 JMP	pop_xgsetF000
(0467) 	}
(0468) }
(0469) 
(0470) void main(void){
(0471) 
(0472) 	
(0473) 	
(0474) 	bspInit();
_main:
    00A8C DBCE      RCALL	_bspInit
(0475) 	
(0476) 	//WIFI_PUTS("i'm WIFI test start!!!");
(0477) 	//ITFR_PUTS("i'm ITFR test start!!!");
(0478) 	//IO_test();
(0479) 	
(0480) 	thread_main();
    00A8D CC73      RJMP	_thread_main
FILE: E:\My_GTAProject\塔城设故板\Software\IO_control.c
(0001) #include "IO_control.h"
(0002) 
(0003) infoMal infoMal_teacher = {0,0,0,0,0};
(0004) infoMal infoMal_student = {0,0,0,0,0};
(0005) 
(0006) uchar resIOJudge[9] = {0};
(0007) 
(0008) void IOInit(void){
(0009) 
(0010) 	DDRA  |= 0x55; 	DDRB  |= 0x55;	DDRC  |= 0x55;	DDRF  |= 0x05;
_IOInit:
    00A8E B38A      IN	R24,0x1A
    00A8F 6585      ORI	R24,0x55
    00A90 BB8A      OUT	0x1A,R24
    00A91 B387      IN	R24,0x17
    00A92 6585      ORI	R24,0x55
    00A93 BB87      OUT	0x17,R24
    00A94 B384      IN	R24,0x14
    00A95 6585      ORI	R24,0x55
    00A96 BB84      OUT	0x14,R24
    00A97 9180 0061 LDS	R24,0x61
    00A99 6085      ORI	R24,5
    00A9A 9380 0061 STS	0x61,R24
(0011) 	PORTA |= 0x55; 	PORTB |= 0x55;	PORTC |= 0x55;	PORTF |= 0x05;
    00A9C B38B      IN	R24,0x1B
    00A9D 6585      ORI	R24,0x55
    00A9E BB8B      OUT	0x1B,R24
    00A9F B388      IN	R24,0x18
    00AA0 6585      ORI	R24,0x55
    00AA1 BB88      OUT	0x18,R24
    00AA2 B385      IN	R24,0x15
    00AA3 6585      ORI	R24,0x55
    00AA4 BB85      OUT	0x15,R24
    00AA5 9180 0062 LDS	R24,0x62
    00AA7 6085      ORI	R24,5
    00AA8 9380 0062 STS	0x62,R24
    00AAA 9508      RET
(0012) }
(0013) 
(0014) void delayTest(void){
(0015) 
(0016) 	 uint a = 65535;
_delayTest:
  a                    --> R16
    00AAB EF0F      LDI	R16,0xFF
    00AAC EF1F      LDI	R17,0xFF
    00AAD C009      RJMP	0x0AB7
(0017) 	 while(--a){
(0018) 	 	asm("nop");asm("nop");asm("nop");
    00AAE 0000      NOP
    00AAF 0000      NOP
    00AB0 0000      NOP
(0019) 		asm("nop");asm("nop");asm("nop");	
    00AB1 0000      NOP
    00AB2 0000      NOP
    00AB3 0000      NOP
(0020) 		asm("nop");asm("nop");asm("nop");	
    00AB4 0000      NOP
    00AB5 0000      NOP
    00AB6 0000      NOP
    00AB7 01C8      MOVW	R24,R16
    00AB8 9701      SBIW	R24,1
    00AB9 018C      MOVW	R16,R24
    00ABA 3000      CPI	R16,0
    00ABB 0701      CPC	R16,R17
    00ABC F789      BNE	0x0AAE
    00ABD 9508      RET
_IO_test:
  count                --> R22
  loop                 --> R10
  a                    --> R20
    00ABE 940E 0D3B CALL	push_xgsetF03C
(0021) 	 }
(0022) }
(0023) 
(0024) void IO_test(void){
(0025) 
(0026) 	const uint count  = 5;
    00AC0 E065      LDI	R22,5
    00AC1 E070      LDI	R23,0
(0027) 	uint a = count;
    00AC2 01AB      MOVW	R20,R22
(0028) 	uchar	 loop;
(0029) 	
(0030) 	DDRA = DDRB = DDRC = DDRF = 0xff;
    00AC3 EF8F      LDI	R24,0xFF
    00AC4 9380 0061 STS	0x61,R24
    00AC6 BB84      OUT	0x14,R24
    00AC7 BB87      OUT	0x17,R24
    00AC8 BB8A      OUT	0x1A,R24
    00AC9 C059      RJMP	0x0B23
(0031) 
(0032) 	while(1){
(0033)  
(0034)  		PORTA = 0x01;
    00ACA E081      LDI	R24,1
    00ACB BB8B      OUT	0x1B,R24
(0035)  		for(loop = 0;loop < 5;loop++){
    00ACC 24AA      CLR	R10
    00ACD C00E      RJMP	0x0ADC
(0036) 		
(0037) 			PORTA = PORTA << 2;
    00ACE B22B      IN	R2,0x1B
    00ACF 0C22      LSL	R2
    00AD0 0C22      LSL	R2
    00AD1 BA2B      OUT	0x1B,R2
    00AD2 C001      RJMP	0x0AD4
(0038) 			while(--a)delayTest();
    00AD3 DFD7      RCALL	_delayTest
    00AD4 01CA      MOVW	R24,R20
    00AD5 9701      SBIW	R24,1
    00AD6 01AC      MOVW	R20,R24
    00AD7 3080      CPI	R24,0
    00AD8 0789      CPC	R24,R25
    00AD9 F7C9      BNE	0x0AD3
(0039) 			a = count;
    00ADA 01AB      MOVW	R20,R22
    00ADB 94A3      INC	R10
    00ADC 2D8A      MOV	R24,R10
    00ADD 3085      CPI	R24,5
    00ADE F378      BCS	0x0ACE
(0040) 		}
(0041)  		PORTB = 0x01;
    00ADF E081      LDI	R24,1
    00AE0 BB88      OUT	0x18,R24
(0042)  		for(loop = 0;loop < 5;loop++){
    00AE1 24AA      CLR	R10
    00AE2 C00E      RJMP	0x0AF1
(0043) 		
(0044) 			PORTB = PORTB << 2;
    00AE3 B228      IN	R2,0x18
    00AE4 0C22      LSL	R2
    00AE5 0C22      LSL	R2
    00AE6 BA28      OUT	0x18,R2
    00AE7 C001      RJMP	0x0AE9
(0045) 			while(--a)delayTest();
    00AE8 DFC2      RCALL	_delayTest
    00AE9 01CA      MOVW	R24,R20
    00AEA 9701      SBIW	R24,1
    00AEB 01AC      MOVW	R20,R24
    00AEC 3080      CPI	R24,0
    00AED 0789      CPC	R24,R25
    00AEE F7C9      BNE	0x0AE8
(0046) 			a = count;
    00AEF 01AB      MOVW	R20,R22
    00AF0 94A3      INC	R10
    00AF1 2D8A      MOV	R24,R10
    00AF2 3085      CPI	R24,5
    00AF3 F378      BCS	0x0AE3
(0047) 		}	
(0048)  		PORTC = 0x01;
    00AF4 E081      LDI	R24,1
    00AF5 BB85      OUT	0x15,R24
(0049)  		for(loop = 0;loop < 5;loop++){
    00AF6 24AA      CLR	R10
    00AF7 C00F      RJMP	0x0B07
(0050) 		
(0051) 			PORTC = PORTC << 2;
    00AF8 B225      IN	R2,0x15
    00AF9 0C22      LSL	R2
    00AFA 0C22      LSL	R2
    00AFB BA25      OUT	0x15,R2
    00AFC C001      RJMP	0x0AFE
(0052) 			while(--a)delayTest();
    00AFD DFAD      RCALL	_delayTest
    00AFE 01CA      MOVW	R24,R20
    00AFF 9701      SBIW	R24,1
    00B00 016C      MOVW	R12,R24
    00B01 01AC      MOVW	R20,R24
    00B02 3080      CPI	R24,0
    00B03 0789      CPC	R24,R25
    00B04 F7C1      BNE	0x0AFD
(0053) 			a = count;
    00B05 01AB      MOVW	R20,R22
    00B06 94A3      INC	R10
    00B07 2D8A      MOV	R24,R10
    00B08 3085      CPI	R24,5
    00B09 F370      BCS	0x0AF8
(0054) 		}	
(0055)  		PORTF = 0x01;
    00B0A E081      LDI	R24,1
    00B0B 9380 0062 STS	0x62,R24
(0056)  		for(loop = 0;loop < 5;loop++){
    00B0D 24AA      CLR	R10
    00B0E C011      RJMP	0x0B20
(0057) 		
(0058) 			PORTF = PORTF << 2;
    00B0F 9020 0062 LDS	R2,0x62
    00B11 0C22      LSL	R2
    00B12 0C22      LSL	R2
    00B13 9220 0062 STS	0x62,R2
    00B15 C001      RJMP	0x0B17
(0059) 			while(--a)delayTest();
    00B16 DF94      RCALL	_delayTest
    00B17 01CA      MOVW	R24,R20
    00B18 9701      SBIW	R24,1
    00B19 016C      MOVW	R12,R24
    00B1A 01AC      MOVW	R20,R24
    00B1B 3080      CPI	R24,0
    00B1C 0789      CPC	R24,R25
    00B1D F7C1      BNE	0x0B16
(0060) 			a = count;
    00B1E 01AB      MOVW	R20,R22
    00B1F 94A3      INC	R10
    00B20 2D8A      MOV	R24,R10
    00B21 3085      CPI	R24,5
    00B22 F360      BCS	0x0B0F
    00B23 CFA6      RJMP	0x0ACA
    00B24 940C 0D44 JMP	pop_xgsetF03C
(0061) 		}	
(0062)  	}
(0063) }
(0064) 
(0065) void IOReinstate(void){
(0066) 
(0067) 	infoMal_teacher.dianfengshan =\
_IOReinstate:
    00B26 2422      CLR	R2
    00B27 9220 05B2 STS	infoMal_teacher+3,R2
    00B29 9220 05B3 STS	infoMal_teacher+4,R2
    00B2B 9220 05B0 STS	infoMal_teacher+1,R2
    00B2D 9220 05B1 STS	infoMal_teacher+2,R2
    00B2F 9220 05AF STS	infoMal_teacher,R2
(0068) 	infoMal_teacher.weibolu =\
(0069) 	infoMal_teacher.dianfanbao =\
(0070) 	infoMal_teacher.xiyiji =\
(0071) 	infoMal_teacher.xiaodugui \
(0072) 	= 0;
(0073) 	
(0074) 	infoMal_student.dianfengshan =\
    00B31 9220 05B7 STS	infoMal_student+3,R2
    00B33 9220 05B8 STS	infoMal_student+4,R2
    00B35 9220 05B5 STS	infoMal_student+1,R2
    00B37 9220 05B6 STS	infoMal_student+2,R2
    00B39 9220 05B4 STS	infoMal_student,R2
(0075) 	infoMal_student.weibolu =\
(0076) 	infoMal_student.dianfanbao =\
(0077) 	infoMal_student.xiyiji =\
(0078) 	infoMal_student.xiaodugui \
(0079) 	= 0;
(0080) 	
(0081) 	IOInit();
    00B3B CF52      RJMP	_IOInit
_OPJudje:
  pt                   --> R22
  temp                 --> R10
  loop                 --> R20
  Base                 --> R12
  S                    --> R10
  T                    --> R14
    00B3C 940E 0D0E CALL	push_xgsetF0FC
    00B3E 2EA2      MOV	R10,R18
    00B3F 2EE0      MOV	R14,R16
    00B40 84CA      LDD	R12,Y+10
(0082) }
(0083) 
(0084) void OPJudje(uchar T,uchar S,uchar Base){ 		  //直接异或比较输出结果
(0085) 
(0086) 	uchar temp,loop,pt;
(0087) 	pt = 0;
    00B41 2766      CLR	R22
(0088) 	
(0089) 	temp = T ^ S;
    00B42 2C2E      MOV	R2,R14
    00B43 242A      EOR	R2,R10
    00B44 2CA2      MOV	R10,R2
(0090) 	for(loop = 0;loop < 8;loop ++){
    00B45 2744      CLR	R20
    00B46 C015      RJMP	0x0B5C
(0091) 			 
(0092) 		if((temp >> loop) & 0x01)resIOJudge[pt++] = Base + loop;
    00B47 2D0A      MOV	R16,R10
    00B48 2F14      MOV	R17,R20
    00B49 940E 0D53 CALL	lsr8
    00B4B 2F80      MOV	R24,R16
    00B4C 7081      ANDI	R24,1
    00B4D F069      BEQ	0x0B5B
    00B4E 2E26      MOV	R2,R22
    00B4F 2433      CLR	R3
    00B50 0121      MOVW	R4,R2
    00B51 5F6F      SUBI	R22,0xFF
    00B52 2C2C      MOV	R2,R12
    00B53 0E24      ADD	R2,R20
    00B54 EB89      LDI	R24,0xB9
    00B55 E095      LDI	R25,5
    00B56 2DE4      MOV	R30,R4
    00B57 27FF      CLR	R31
    00B58 0FE8      ADD	R30,R24
    00B59 1FF9      ADC	R31,R25
    00B5A 8220      ST	Z,R2
    00B5B 9543      INC	R20
    00B5C 3048      CPI	R20,0x8
    00B5D F348      BCS	0x0B47
    00B5E 940C 0D03 JMP	pop_xgsetF0FC
_dianfengshan_IO:
  a                    --> R20
  obj                  --> R22
    00B60 940E 0D2D CALL	push_xgsetF00C
    00B62 2F42      MOV	R20,R18
    00B63 2F60      MOV	R22,R16
(0093) 	}
(0094) 	
(0095) 	//resIOJudge[6] = temp;						  		 //测试比较结果输出
(0096) 	//resIOJudge[7] = infoMal_teacher.xiaodugui;
(0097) 	//resIOJudge[8] = infoMal_student.xiaodugui;
(0098) }
(0099) 
(0100) //单字节从右到左分别表示设故编号
(0101) //1-4号电风扇、5-6号电饭煲、7-9号微波炉、10-12号消毒柜、13-14号洗衣机
(0102) void dianfengshan_IO(uchar obj,uchar a){	   //1-4号电风扇
(0103) 
(0104) 	if(obj == 'T'){		   			 		   //教师端设故信息更新
    00B64 3564      CPI	R22,0x54
    00B65 F529      BNE	0x0B8B
(0105) 	
(0106) 		infoMal_teacher.dianfengshan |= (1 << (a-1));
    00B66 2F14      MOV	R17,R20
    00B67 5011      SUBI	R17,1
    00B68 E001      LDI	R16,1
    00B69 940E 0D4D CALL	lsl8
    00B6B 9020 05AF LDS	R2,infoMal_teacher
    00B6D 2A20      OR	R2,R16
    00B6E 9220 05AF STS	infoMal_teacher,R2
(0107) 		//IO Opreation here
(0108) 		switch(a){
    00B70 2EA4      MOV	R10,R20
    00B71 24BB      CLR	R11
    00B72 01C5      MOVW	R24,R10
    00B73 3081      CPI	R24,1
    00B74 E0E0      LDI	R30,0
    00B75 079E      CPC	R25,R30
    00B76 F069      BEQ	0x0B84
    00B77 3082      CPI	R24,2
    00B78 E0E0      LDI	R30,0
    00B79 079E      CPC	R25,R30
    00B7A F059      BEQ	0x0B86
    00B7B 3083      CPI	R24,3
    00B7C E0E0      LDI	R30,0
    00B7D 079E      CPC	R25,R30
    00B7E F049      BEQ	0x0B88
    00B7F 3084      CPI	R24,4
    00B80 E0E0      LDI	R30,0
    00B81 079E      CPC	R25,R30
    00B82 F039      BEQ	0x0B8A
    00B83 C007      RJMP	0x0B8B
(0109) 	
(0110) 			case  1:	   PORTA &= (~0x01);  break;
    00B84 98D8      CBI	0x1B,0
    00B85 C005      RJMP	0x0B8B
(0111) 			case  2:   	   PORTA &= (~0x04);  break;
    00B86 98DA      CBI	0x1B,2
    00B87 C003      RJMP	0x0B8B
(0112) 			case  3:   	   PORTA &= (~0x10);  break;
    00B88 98DC      CBI	0x1B,4
    00B89 C001      RJMP	0x0B8B
(0113) 			case  4:   	   PORTA &= (~0x40);  break;
    00B8A 98DE      CBI	0x1B,6
(0114) 			default:   	   break;
(0115) 		}
(0116) 	} 
(0117) 	if(obj == 'S'){		   		 			  //学生端设故信息更新
    00B8B 3563      CPI	R22,0x53
    00B8C F519      BNE	0x0BB0
(0118) 	
(0119) 		infoMal_student.dianfengshan |= (1 << (a-1));
    00B8D 2F14      MOV	R17,R20
    00B8E 5011      SUBI	R17,1
    00B8F E001      LDI	R16,1
    00B90 940E 0D4D CALL	lsl8
    00B92 9020 05B4 LDS	R2,infoMal_student
    00B94 2A20      OR	R2,R16
    00B95 9220 05B4 STS	infoMal_student,R2
(0120) 		//IO Opreation here
(0121) 		switch(a){
    00B97 2755      CLR	R21
    00B98 3041      CPI	R20,1
    00B99 E0E0      LDI	R30,0
    00B9A 075E      CPC	R21,R30
    00B9B F069      BEQ	0x0BA9
    00B9C 3042      CPI	R20,2
    00B9D E0E0      LDI	R30,0
    00B9E 075E      CPC	R21,R30
    00B9F F059      BEQ	0x0BAB
    00BA0 3043      CPI	R20,3
    00BA1 E0E0      LDI	R30,0
    00BA2 075E      CPC	R21,R30
    00BA3 F049      BEQ	0x0BAD
    00BA4 3044      CPI	R20,4
    00BA5 E0E0      LDI	R30,0
    00BA6 075E      CPC	R21,R30
    00BA7 F039      BEQ	0x0BAF
    00BA8 C007      RJMP	0x0BB0
(0122) 	
(0123) 			case  1:	   PORTA |= (0x01);  break;
    00BA9 9AD8      SBI	0x1B,0
    00BAA C005      RJMP	0x0BB0
(0124) 			case  2:   	   PORTA |= (0x04);  break;
    00BAB 9ADA      SBI	0x1B,2
    00BAC C003      RJMP	0x0BB0
(0125) 			case  3:   	   PORTA |= (0x10);  break;
    00BAD 9ADC      SBI	0x1B,4
    00BAE C001      RJMP	0x0BB0
(0126) 			case  4:   	   PORTA |= (0x40);  break;
    00BAF 9ADE      SBI	0x1B,6
(0127) 			default:   	   break;
(0128) 		}	
(0129) 	}
    00BB0 940C 0D34 JMP	pop_xgsetF00C
_dianfanbao_IO:
  a                    --> R20
  obj                  --> R22
    00BB2 940E 0D2D CALL	push_xgsetF00C
    00BB4 2F42      MOV	R20,R18
    00BB5 2F60      MOV	R22,R16
(0130) }
(0131) 
(0132) void dianfanbao_IO(uchar obj,uchar a){	  	   //5-7号电饭煲
(0133) 
(0134) 	if(obj == 'T'){		 		   			   //教师端设故信息更新
    00BB6 3564      CPI	R22,0x54
    00BB7 F519      BNE	0x0BDB
(0135) 	
(0136) 		infoMal_teacher.dianfanbao |= (1 << (a-1));
    00BB8 2F14      MOV	R17,R20
    00BB9 5011      SUBI	R17,1
    00BBA E001      LDI	R16,1
    00BBB 940E 0D4D CALL	lsl8
    00BBD 9020 05B0 LDS	R2,infoMal_teacher+1
    00BBF 2A20      OR	R2,R16
    00BC0 9220 05B0 STS	infoMal_teacher+1,R2
(0137) 		//IO Opreation here
(0138) 		switch(a){
    00BC2 2EA4      MOV	R10,R20
    00BC3 24BB      CLR	R11
    00BC4 01C5      MOVW	R24,R10
    00BC5 3081      CPI	R24,1
    00BC6 E0E0      LDI	R30,0
    00BC7 079E      CPC	R25,R30
    00BC8 F069      BEQ	0x0BD6
    00BC9 3082      CPI	R24,2
    00BCA E0E0      LDI	R30,0
    00BCB 079E      CPC	R25,R30
    00BCC F059      BEQ	0x0BD8
    00BCD 3083      CPI	R24,3
    00BCE E0E0      LDI	R30,0
    00BCF 079E      CPC	R25,R30
    00BD0 F049      BEQ	0x0BDA
    00BD1 3084      CPI	R24,4
    00BD2 E0E0      LDI	R30,0
    00BD3 079E      CPC	R25,R30
    00BD4 F031      BEQ	0x0BDB
    00BD5 C005      RJMP	0x0BDB
(0139) 	
(0140) 			case  1:	   PORTB &= (~0x01);  break;
    00BD6 98C0      CBI	0x18,0
    00BD7 C003      RJMP	0x0BDB
(0141) 			case  2:   	   PORTB &= (~0x04);  break;
    00BD8 98C2      CBI	0x18,2
    00BD9 C001      RJMP	0x0BDB
(0142) 			case  3:   	   PORTB &= (~0x10);  break;
    00BDA 98C4      CBI	0x18,4
(0143) 			case  4:   	   break;
(0144) 			default:   	   break;
(0145) 		}
(0146) 	} 	
(0147) 	if(obj == 'S'){				   	  	 	   //学生端设故信息更新
    00BDB 3563      CPI	R22,0x53
    00BDC F4E9      BNE	0x0BFA
(0148) 	
(0149) 		infoMal_student.dianfanbao |= (1 << (a-1));
    00BDD 2F14      MOV	R17,R20
    00BDE 5011      SUBI	R17,1
    00BDF E001      LDI	R16,1
    00BE0 940E 0D4D CALL	lsl8
    00BE2 9020 05B5 LDS	R2,infoMal_student+1
    00BE4 2A20      OR	R2,R16
    00BE5 9220 05B5 STS	infoMal_student+1,R2
(0150) 		//IO Opreation here
(0151) 		switch(a){
    00BE7 2755      CLR	R21
    00BE8 3041      CPI	R20,1
    00BE9 E0E0      LDI	R30,0
    00BEA 075E      CPC	R21,R30
    00BEB F049      BEQ	0x0BF5
    00BEC 3042      CPI	R20,2
    00BED E0E0      LDI	R30,0
    00BEE 075E      CPC	R21,R30
    00BEF F039      BEQ	0x0BF7
    00BF0 3043      CPI	R20,3
    00BF1 E0E0      LDI	R30,0
    00BF2 075E      CPC	R21,R30
    00BF3 F029      BEQ	0x0BF9
    00BF4 C005      RJMP	0x0BFA
(0152) 	
(0153) 			case  1:	   PORTB |= (0x01);  break;
    00BF5 9AC0      SBI	0x18,0
    00BF6 C003      RJMP	0x0BFA
(0154) 			case  2:   	   PORTB |= (0x04);  break;
    00BF7 9AC2      SBI	0x18,2
    00BF8 C001      RJMP	0x0BFA
(0155) 			case  3:   	   PORTB |= (0x10);  break;
    00BF9 9AC4      SBI	0x18,4
(0156) 			default:   	   break;
(0157) 		}
(0158) 	}	
    00BFA 940C 0D34 JMP	pop_xgsetF00C
_weibolu_IO:
  a                    --> R20
  obj                  --> R22
    00BFC 940E 0D2D CALL	push_xgsetF00C
    00BFE 2F42      MOV	R20,R18
    00BFF 2F60      MOV	R22,R16
(0159) }
(0160) 
(0161) void weibolu_IO(uchar obj,uchar a){			   //8-9号微波炉
(0162) 
(0163) 	if(obj == 'T'){	  						   //教师端设故信息更新
    00C00 3564      CPI	R22,0x54
    00C01 F4C9      BNE	0x0C1B
(0164) 	
(0165) 		infoMal_teacher.weibolu |= (1 << (a-1));
    00C02 2F14      MOV	R17,R20
    00C03 5011      SUBI	R17,1
    00C04 E001      LDI	R16,1
    00C05 940E 0D4D CALL	lsl8
    00C07 9020 05B1 LDS	R2,infoMal_teacher+2
    00C09 2A20      OR	R2,R16
    00C0A 9220 05B1 STS	infoMal_teacher+2,R2
(0166) 		//IO Opreation here
(0167) 		switch(a){
    00C0C 2EA4      MOV	R10,R20
    00C0D 24BB      CLR	R11
    00C0E 01C5      MOVW	R24,R10
    00C0F 3081      CPI	R24,1
    00C10 E0E0      LDI	R30,0
    00C11 079E      CPC	R25,R30
    00C12 F029      BEQ	0x0C18
    00C13 3082      CPI	R24,2
    00C14 E0E0      LDI	R30,0
    00C15 079E      CPC	R25,R30
    00C16 F019      BEQ	0x0C1A
    00C17 C003      RJMP	0x0C1B
(0168) 	
(0169) 			case  1:	   PORTB &= (~0x40);  break;
    00C18 98C6      CBI	0x18,6
    00C19 C001      RJMP	0x0C1B
(0170) 			case  2:   	   PORTC &= (~0x01);  break;
    00C1A 98A8      CBI	0x15,0
(0171) 			default:   	   break;
(0172) 		}
(0173) 	} 	
(0174) 	if(obj == 'S'){				   	  	 	   //学生端设故信息更新
    00C1B 3563      CPI	R22,0x53
    00C1C F4B9      BNE	0x0C34
(0175) 	
(0176) 		infoMal_student.weibolu |= (1 << (a-1));
    00C1D 2F14      MOV	R17,R20
    00C1E 5011      SUBI	R17,1
    00C1F E001      LDI	R16,1
    00C20 940E 0D4D CALL	lsl8
    00C22 9020 05B6 LDS	R2,infoMal_student+2
    00C24 2A20      OR	R2,R16
    00C25 9220 05B6 STS	infoMal_student+2,R2
(0177) 		//IO Opreation here
(0178) 		switch(a){
    00C27 2755      CLR	R21
    00C28 3041      CPI	R20,1
    00C29 E0E0      LDI	R30,0
    00C2A 075E      CPC	R21,R30
    00C2B F029      BEQ	0x0C31
    00C2C 3042      CPI	R20,2
    00C2D E0E0      LDI	R30,0
    00C2E 075E      CPC	R21,R30
    00C2F F019      BEQ	0x0C33
    00C30 C003      RJMP	0x0C34
(0179) 	
(0180) 			case  1:	   PORTB |= (0x40);  break;
    00C31 9AC6      SBI	0x18,6
    00C32 C001      RJMP	0x0C34
(0181) 			case  2:   	   PORTC |= (0x01);  break;
    00C33 9AA8      SBI	0x15,0
(0182) 			default:   	   break;
(0183) 		}
(0184) 	}	
    00C34 940C 0D34 JMP	pop_xgsetF00C
_xiaodugui_IO:
  a                    --> R20
  obj                  --> R22
    00C36 940E 0D2D CALL	push_xgsetF00C
    00C38 2F42      MOV	R20,R18
    00C39 2F60      MOV	R22,R16
(0185) }
(0186) 
(0187) void xiaodugui_IO(uchar obj,uchar a){	 	   //10-11号消毒柜
(0188) 
(0189) 	if(obj == 'T'){				  			   //教师端设故信息更新
    00C3A 3564      CPI	R22,0x54
    00C3B F4C9      BNE	0x0C55
(0190) 	
(0191) 		infoMal_teacher.xiaodugui |= (1 << (a-1));
    00C3C 2F14      MOV	R17,R20
    00C3D 5011      SUBI	R17,1
    00C3E E001      LDI	R16,1
    00C3F 940E 0D4D CALL	lsl8
    00C41 9020 05B2 LDS	R2,infoMal_teacher+3
    00C43 2A20      OR	R2,R16
    00C44 9220 05B2 STS	infoMal_teacher+3,R2
(0192) 		//IO Opreation here
(0193) 		switch(a){
    00C46 2EA4      MOV	R10,R20
    00C47 24BB      CLR	R11
    00C48 01C5      MOVW	R24,R10
    00C49 3081      CPI	R24,1
    00C4A E0E0      LDI	R30,0
    00C4B 079E      CPC	R25,R30
    00C4C F029      BEQ	0x0C52
    00C4D 3082      CPI	R24,2
    00C4E E0E0      LDI	R30,0
    00C4F 079E      CPC	R25,R30
    00C50 F019      BEQ	0x0C54
    00C51 C003      RJMP	0x0C55
(0194) 	
(0195) 			case  1:	   PORTC &= (~0x04);  break;
    00C52 98AA      CBI	0x15,2
    00C53 C001      RJMP	0x0C55
(0196) 			case  2:   	   PORTC &= (~0x10);  break;
    00C54 98AC      CBI	0x15,4
(0197) 			default:   	   break;
(0198) 		}
(0199) 	} 
(0200) 	if(obj == 'S'){				  	 	   	   //学生端设故信息更新
    00C55 3563      CPI	R22,0x53
    00C56 F4B9      BNE	0x0C6E
(0201) 	
(0202) 		infoMal_student.xiaodugui |= (1 << (a-1));
    00C57 2F14      MOV	R17,R20
    00C58 5011      SUBI	R17,1
    00C59 E001      LDI	R16,1
    00C5A 940E 0D4D CALL	lsl8
    00C5C 9020 05B7 LDS	R2,infoMal_student+3
    00C5E 2A20      OR	R2,R16
    00C5F 9220 05B7 STS	infoMal_student+3,R2
(0203) 		//IO Opreation here
(0204) 		switch(a){
    00C61 2755      CLR	R21
    00C62 3041      CPI	R20,1
    00C63 E0E0      LDI	R30,0
    00C64 075E      CPC	R21,R30
    00C65 F029      BEQ	0x0C6B
    00C66 3042      CPI	R20,2
    00C67 E0E0      LDI	R30,0
    00C68 075E      CPC	R21,R30
    00C69 F019      BEQ	0x0C6D
    00C6A C003      RJMP	0x0C6E
(0205) 	
(0206) 			case  1:	   PORTC |= (0x04);  break;
    00C6B 9AAA      SBI	0x15,2
    00C6C C001      RJMP	0x0C6E
(0207) 			case  2:   	   PORTC |= (0x10);  break;
    00C6D 9AAC      SBI	0x15,4
(0208) 			default:   	   break;
(0209) 		}
(0210) 	}	
    00C6E 940C 0D34 JMP	pop_xgsetF00C
_xiyiji_IO:
  a                    --> R20
  obj                  --> R22
    00C70 940E 0D2D CALL	push_xgsetF00C
    00C72 2F42      MOV	R20,R18
    00C73 2F60      MOV	R22,R16
(0211) }
(0212) 
(0213) void xiyiji_IO(uchar obj,uchar a){			   //12-14号洗衣机
(0214) 
(0215) 	if(obj == 'T'){	 		   				   //教师端设故信息更新
    00C74 3564      CPI	R22,0x54
    00C75 F539      BNE	0x0C9D
(0216) 	
(0217) 		infoMal_teacher.xiyiji |= (1 << (a-1));
    00C76 2F14      MOV	R17,R20
    00C77 5011      SUBI	R17,1
    00C78 E001      LDI	R16,1
    00C79 940E 0D4D CALL	lsl8
    00C7B 9020 05B3 LDS	R2,infoMal_teacher+4
    00C7D 2A20      OR	R2,R16
    00C7E 9220 05B3 STS	infoMal_teacher+4,R2
(0218) 		//IO Opreation here
(0219) 		switch(a){
    00C80 2EA4      MOV	R10,R20
    00C81 24BB      CLR	R11
    00C82 01C5      MOVW	R24,R10
    00C83 3081      CPI	R24,1
    00C84 E0E0      LDI	R30,0
    00C85 079E      CPC	R25,R30
    00C86 F049      BEQ	0x0C90
    00C87 3082      CPI	R24,2
    00C88 E0E0      LDI	R30,0
    00C89 079E      CPC	R25,R30
    00C8A F039      BEQ	0x0C92
    00C8B 3083      CPI	R24,3
    00C8C E0E0      LDI	R30,0
    00C8D 079E      CPC	R25,R30
    00C8E F049      BEQ	0x0C98
    00C8F C00D      RJMP	0x0C9D
(0220) 	
(0221) 			case  1:	   PORTC &= (~0x40);  break;
    00C90 98AE      CBI	0x15,6
    00C91 C00B      RJMP	0x0C9D
(0222) 			case  2:   	   PORTF &= (~0x01);  break;
    00C92 9180 0062 LDS	R24,0x62
    00C94 7F8E      ANDI	R24,0xFE
    00C95 9380 0062 STS	0x62,R24
    00C97 C005      RJMP	0x0C9D
(0223) 			case  3:   	   PORTF &= (~0x04);  break;
    00C98 9180 0062 LDS	R24,0x62
    00C9A 7F8B      ANDI	R24,0xFB
    00C9B 9380 0062 STS	0x62,R24
(0224) 			default:   	   break;
(0225) 		}
(0226) 	} 	
(0227) 	if(obj == 'S'){			   	  	 		   //学生端设故信息更新
    00C9D 3563      CPI	R22,0x53
    00C9E F529      BNE	0x0CC4
(0228) 	
(0229) 		infoMal_student.xiyiji |= (1 << (a-1));
    00C9F 2F14      MOV	R17,R20
    00CA0 5011      SUBI	R17,1
    00CA1 E001      LDI	R16,1
    00CA2 940E 0D4D CALL	lsl8
    00CA4 9020 05B8 LDS	R2,infoMal_student+4
    00CA6 2A20      OR	R2,R16
    00CA7 9220 05B8 STS	infoMal_student+4,R2
(0230) 		//IO Opreation here
(0231) 		switch(a){
    00CA9 2755      CLR	R21
    00CAA 3041      CPI	R20,1
    00CAB E0E0      LDI	R30,0
    00CAC 075E      CPC	R21,R30
    00CAD F049      BEQ	0x0CB7
    00CAE 3042      CPI	R20,2
    00CAF E0E0      LDI	R30,0
    00CB0 075E      CPC	R21,R30
    00CB1 F039      BEQ	0x0CB9
    00CB2 3043      CPI	R20,3
    00CB3 E0E0      LDI	R30,0
    00CB4 075E      CPC	R21,R30
    00CB5 F049      BEQ	0x0CBF
    00CB6 C00D      RJMP	0x0CC4
(0232) 	
(0233) 			case  1:	   PORTC |= (0x40);  break;
    00CB7 9AAE      SBI	0x15,6
    00CB8 C00B      RJMP	0x0CC4
(0234) 			case  2:   	   PORTF |= (0x01);  break;
    00CB9 9180 0062 LDS	R24,0x62
    00CBB 6081      ORI	R24,1
    00CBC 9380 0062 STS	0x62,R24
    00CBE C005      RJMP	0x0CC4
(0235) 			case  3:   	   PORTF |= (0x04);  break;
    00CBF 9180 0062 LDS	R24,0x62
    00CC1 6084      ORI	R24,4
    00CC2 9380 0062 STS	0x62,R24
(0236) 			default:   	   break;
(0237) 		}
(0238) 	}	
FILE: <library>
    00CC4 940C 0D34 JMP	pop_xgsetF00C
_memset:
    00CC6 8188      LD	R24,Y
    00CC7 8199      LDD	R25,Y+1
    00CC8 3080      CPI	R24,0
    00CC9 0789      CPC	R24,R25
    00CCA F029      BEQ	0x0CD0
    00CCB 2FE0      MOV	R30,R16
    00CCC 2FF1      MOV	R31,R17
    00CCD 9321      ST	Z+,R18
    00CCE 9701      SBIW	R24,1
    00CCF F7E9      BNE	0x0CCD
    00CD0 9508      RET
_strcmp:
    00CD1 2FE0      MOV	R30,R16
    00CD2 2FF1      MOV	R31,R17
    00CD3 2FA2      MOV	R26,R18
    00CD4 2FB3      MOV	R27,R19
    00CD5 9101      LD	R16,Z+
    00CD6 911D      LD	R17,X+
    00CD7 1B01      SUB	R16,R17
    00CD8 F419      BNE	0x0CDC
    00CD9 2311      TST	R17
    00CDA F7D1      BNE	0x0CD5
    00CDB 2700      CLR	R16
    00CDC 0B11      SBC	R17,R17
    00CDD 9508      RET
_strcpy:
    00CDE 2FA0      MOV	R26,R16
    00CDF 2FB1      MOV	R27,R17
    00CE0 2FE2      MOV	R30,R18
    00CE1 2FF3      MOV	R31,R19
    00CE2 9001      LD	R0,Z+
    00CE3 920D      ST	X+,R0
    00CE4 2000      TST	R0
    00CE5 F7E1      BNE	0x0CE2
    00CE6 9508      RET
mod16u:
    00CE7 9468      BSET	6
    00CE8 C001      RJMP	xdiv16u
div16u:
    00CE9 94E8      BCLR	6
xdiv16u:
    00CEA 92EA      ST	-Y,R14
    00CEB 92FA      ST	-Y,R15
    00CEC 938A      ST	-Y,R24
    00CED 24EE      CLR	R14
    00CEE 24FF      CLR	R15
    00CEF E180      LDI	R24,0x10
    00CF0 0F00      LSL	R16
    00CF1 1F11      ROL	R17
    00CF2 1CEE      ROL	R14
    00CF3 1CFF      ROL	R15
    00CF4 16E2      CP	R14,R18
    00CF5 06F3      CPC	R15,R19
    00CF6 F018      BCS	0x0CFA
    00CF7 1AE2      SUB	R14,R18
    00CF8 0AF3      SBC	R15,R19
    00CF9 9503      INC	R16
    00CFA 958A      DEC	R24
    00CFB F7A1      BNE	0x0CF0
    00CFC F416      BRTC	0x0CFF
    00CFD 2D0E      MOV	R16,R14
    00CFE 2D1F      MOV	R17,R15
    00CFF 9189      LD	R24,Y+
    00D00 90F9      LD	R15,Y+
    00D01 90E9      LD	R14,Y+
    00D02 9508      RET
pop_xgsetF0FC:
    00D03 90A9      LD	R10,Y+
    00D04 90B9      LD	R11,Y+
    00D05 90C9      LD	R12,Y+
    00D06 90D9      LD	R13,Y+
    00D07 90E9      LD	R14,Y+
    00D08 90F9      LD	R15,Y+
    00D09 9149      LD	R20,Y+
    00D0A 9159      LD	R21,Y+
    00D0B 9169      LD	R22,Y+
    00D0C 9179      LD	R23,Y+
    00D0D 9508      RET
push_xgsetF0FC:
    00D0E 937A      ST	-Y,R23
    00D0F 936A      ST	-Y,R22
push_xgset30FC:
    00D10 935A      ST	-Y,R21
    00D11 934A      ST	-Y,R20
push_xgset00FC:
    00D12 92FA      ST	-Y,R15
    00D13 92EA      ST	-Y,R14
push_xgset003C:
    00D14 92DA      ST	-Y,R13
    00D15 92CA      ST	-Y,R12
    00D16 92BA      ST	-Y,R11
    00D17 92AA      ST	-Y,R10
    00D18 9508      RET
push_xgset300C:
    00D19 935A      ST	-Y,R21
    00D1A 934A      ST	-Y,R20
    00D1B 92BA      ST	-Y,R11
    00D1C 92AA      ST	-Y,R10
    00D1D 9508      RET
pop_xgset300C:
    00D1E 90A9      LD	R10,Y+
    00D1F 90B9      LD	R11,Y+
    00D20 9149      LD	R20,Y+
    00D21 9159      LD	R21,Y+
    00D22 9508      RET
push_xgsetF000:
    00D23 937A      ST	-Y,R23
    00D24 936A      ST	-Y,R22
    00D25 935A      ST	-Y,R21
    00D26 934A      ST	-Y,R20
    00D27 9508      RET
pop_xgsetF000:
    00D28 9149      LD	R20,Y+
    00D29 9159      LD	R21,Y+
    00D2A 9169      LD	R22,Y+
    00D2B 9179      LD	R23,Y+
    00D2C 9508      RET
push_xgsetF00C:
    00D2D 937A      ST	-Y,R23
    00D2E 936A      ST	-Y,R22
    00D2F 935A      ST	-Y,R21
    00D30 934A      ST	-Y,R20
    00D31 92BA      ST	-Y,R11
    00D32 92AA      ST	-Y,R10
    00D33 9508      RET
pop_xgsetF00C:
    00D34 90A9      LD	R10,Y+
    00D35 90B9      LD	R11,Y+
    00D36 9149      LD	R20,Y+
    00D37 9159      LD	R21,Y+
    00D38 9169      LD	R22,Y+
    00D39 9179      LD	R23,Y+
    00D3A 9508      RET
push_xgsetF03C:
    00D3B 937A      ST	-Y,R23
    00D3C 936A      ST	-Y,R22
    00D3D 935A      ST	-Y,R21
    00D3E 934A      ST	-Y,R20
    00D3F 92DA      ST	-Y,R13
    00D40 92CA      ST	-Y,R12
    00D41 92BA      ST	-Y,R11
    00D42 92AA      ST	-Y,R10
    00D43 9508      RET
pop_xgsetF03C:
    00D44 90A9      LD	R10,Y+
    00D45 90B9      LD	R11,Y+
    00D46 90C9      LD	R12,Y+
    00D47 90D9      LD	R13,Y+
    00D48 9149      LD	R20,Y+
    00D49 9159      LD	R21,Y+
    00D4A 9169      LD	R22,Y+
    00D4B 9179      LD	R23,Y+
    00D4C 9508      RET
lsl8:
    00D4D 2311      TST	R17
    00D4E F019      BEQ	0x0D52
    00D4F 0F00      LSL	R16
    00D50 951A      DEC	R17
    00D51 CFFB      RJMP	lsl8
    00D52 9508      RET
lsr8:
    00D53 2311      TST	R17
    00D54 F019      BEQ	0x0D58
    00D55 9506      LSR	R16
    00D56 951A      DEC	R17
    00D57 CFFB      RJMP	lsr8
    00D58 9508      RET
